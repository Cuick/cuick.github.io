<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on K&#39;s blog!</title>
    <link>http://cuick.github.io/categories/python/</link>
    <description>Recent content in Python on K&#39;s blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 19 Mar 2016 21:15:49 +0800</lastBuildDate>
    <atom:link href="http://cuick.github.io/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>线程安全与GIL</title>
      <link>http://cuick.github.io/python/102/</link>
      <pubDate>Sat, 19 Mar 2016 21:15:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/102/</guid>
      <description>

&lt;h2 id=&#34;引入:b66e25cf931c5c75968256c4152b6090&#34;&gt;引入&lt;/h2&gt;

&lt;p&gt;多核时代到来。为了更好利用多核，就要讲到进程与线程，区别在于是否共享资源，前者是独立的后这是共享的。&lt;br /&gt;
多线程环境最大的问题就是资源的竞争 死锁 数据修改。
于是就有了线程安全的问题。&lt;/p&gt;

&lt;h2 id=&#34;线程安全:b66e25cf931c5c75968256c4152b6090&#34;&gt;线程安全&lt;/h2&gt;

&lt;p&gt;在多线程的环境下, 线程安全能够保证多个线程同时执行时程序依旧运行正确, 而且要保证对于共享的数据,可以由多个线程存取,但是同一时刻只能有一个线程进行存取.&lt;/p&gt;

&lt;p&gt;加锁可以保证存取操作的唯一性, 从而保证同一时刻只有一个线程对共享数据存取.&lt;/p&gt;

&lt;p&gt;通常加锁也有2种不同的粒度的锁:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fine-grained(所谓的细粒度), 那么程序员需要自行地加,解锁来保证线程安全&lt;/li&gt;
&lt;li&gt;coarse-grained(所谓的粗粒度), 那么语言层面本身维护着一个全局的锁机制,用来保证线程安全&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前一种方式比较典型的是 java, Jython 等, 后一种方式比较典型的是 CPython (即Python).&lt;/p&gt;

&lt;p&gt;Python中的全局锁机制,便是 GIL (Global Interpreter Lock)&lt;/p&gt;

&lt;h2 id=&#34;什么是gil:b66e25cf931c5c75968256c4152b6090&#34;&gt;什么是GIL&lt;/h2&gt;

&lt;p&gt;全局解释器锁（GIL）是一种互斥锁，由程序语言解析线程持有，用于避免代码共享可能导致的线程安全问题。在支持GIL的语言中，每一个解释器进程中都会含有一个GIL。&lt;/p&gt;

&lt;p&gt;每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.&lt;/p&gt;

&lt;p&gt;那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行, 多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.&lt;/p&gt;

&lt;h4 id=&#34;gil应用:b66e25cf931c5c75968256c4152b6090&#34;&gt;GIL应用&lt;/h4&gt;

&lt;p&gt;一些支持 GIL 的语言的实现包括 CPython（Python 语言最被广泛使用的一种实现），Ruby MRI（Ruby 的推荐实现，GIL 在 Ruby 中被称为 Global VM Lock）&lt;/p&gt;

&lt;p&gt;基于 JVM 的上述语言的等价实现（Jython 和 JRuby）不使用 GIL。IronPython 和 IronRuby 被实现成微软的动态语言运行时，并在其中避免使用 GIL 。&lt;/p&gt;

&lt;h4 id=&#34;关于gil的争议:b66e25cf931c5c75968256c4152b6090&#34;&gt;关于GIL的争议&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;认为应该去除 GIL 的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不顺应计算机的发展潮流(多核时代已经到来, 而 GIL 会很影响多核的使用)&lt;/li&gt;
&lt;li&gt;大幅度提升多线程程序的速度&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;认为不应该去除 GIL 的(如果去掉,会):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;写python的扩展(module)时会遇到锁的问题,程序员需要繁琐地加解锁来保证线程安全&lt;/li&gt;
&lt;li&gt;会较大幅度地减低单线程程序的速度&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;gil设计的缺陷:b66e25cf931c5c75968256c4152b6090&#34;&gt;GIL设计的缺陷&lt;/h4&gt;

&lt;p&gt;基于pcode数量的调度方式&lt;br /&gt;
为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度&lt;br /&gt;
当其他在其他核心上的线程被唤醒时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。&lt;/p&gt;

&lt;p&gt;Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。&lt;/p&gt;

&lt;h4 id=&#34;解决办法:b66e25cf931c5c75968256c4152b6090&#34;&gt;解决办法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;用multiprocess替代Thread&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。&lt;/p&gt;

&lt;p&gt;当然multiprocess也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocess由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。具体难点在哪有兴趣的读者可以扩展阅读 这篇文章&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用其他解析器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前也提到了既然GIL只是CPython的产物，那么其他解析器是不是更好呢？没错，像JPython和IronPython这样的解析器由于实现语言的特性，他们不需要GIL的帮助。然而由于用了Java/C#用于解析器实现，他们也失去了利用社区众多C语言模块有用特性的机会。所以这些解析器也因此一直都比较小众。毕竟功能和性能大家在初期都会选择前者， Done is better than perfect 。
所以没救了么？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;另一个改进 Reworking the GIL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将切换颗粒度从基于opcode计数改成基于时间片计数&lt;/li&gt;
&lt;li&gt;避免最近一次释放GIL锁的线程再次被立即调度&lt;/li&gt;
&lt;li&gt;新增线程优先级功能（高优先级线程可以迫使其他线程释放所持有的GIL锁）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结:b66e25cf931c5c75968256c4152b6090&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;Python GIL其实是功能和性能之间权衡后的产物，它尤其存在的合理性，也有较难改变的客观因素。从本分的分析中，我们可以做以下一些简单的总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GIL在较长一段时间内将会继续存在，但是会不断对其进行改进&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;参考文章:b66e25cf931c5c75968256c4152b6090&#34;&gt;参考文章：&lt;/h5&gt;

&lt;p&gt;1.&lt;a href=&#34;http://www.tuicool.com/articles/7zIra2r&#34;&gt;http://www.tuicool.com/articles/7zIra2r&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;http://my.oschina.net/moooofly/blog/178531&#34;&gt;http://my.oschina.net/moooofly/blog/178531&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>http://cuick.github.io/python/101/</link>
      <pubDate>Sat, 19 Mar 2016 20:24:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/101/</guid>
      <description>&lt;p&gt;闭包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def make_addr(addend):
    def addr(augend):
        return augend + addend
    return addr

p = make_addr(23)
q = make_addr(42)

print p(10)
print q(10)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Twisted基础</title>
      <link>http://cuick.github.io/twisted/twisted_basic/</link>
      <pubDate>Sat, 27 Feb 2016 22:17:23 +0800</pubDate>
      
      <guid>http://cuick.github.io/twisted/twisted_basic/</guid>
      <description>

&lt;h1 id=&#34;网络编程:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;网络编程&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;poll&lt;/li&gt;
&lt;li&gt;epoll&lt;/li&gt;
&lt;li&gt;greenlet&lt;/li&gt;
&lt;li&gt;gevent&lt;/li&gt;
&lt;li&gt;gevent是基于协程的高性能Python网络库，相比Twisted、Stackless等，gevent使用libev事件循环，因此速度很快、性能很好，使用greenlet提供高层的同步API，因此非常轻量。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elias.cn/Python/PyConcurrency&#34;&gt;http://www.elias.cn/Python/PyConcurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/yueguanghaidao/&#34;&gt;http://blog.csdn.net/yueguanghaidao/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;twisted:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Twisted&lt;/h1&gt;

&lt;h3 id=&#34;twisted特点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;twisted特点：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在一个回调函数执行过程中，实际上Twisted的循环是被有效地阻塞在我们的代码上的。因此，因此我们应该确保回调函数不要浪费时间（尽快返回）。&lt;/li&gt;
&lt;li&gt;很多标准的Python方法没有办法转换为非阻塞方式。例如，os.system中的很多方法会在子进程完成前一直处于阻塞状态。这也就是它工作的方式。所以当你使用Twisted时，避开使用os.system。&lt;/li&gt;
&lt;li&gt;我们为Twisted程序写的API必须是异步的&lt;/li&gt;
&lt;li&gt;不能将同步与异步代码混合起来使用&lt;/li&gt;
&lt;li&gt;我们可以在自己的代码中写回调函数，正如Twisted做的那样&lt;/li&gt;
&lt;li&gt;并且，我们需要写处理错误信息的回调函数&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;reactor:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Reactor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个真正reactor模式的实现是需要实现循环独立抽象出来并具有如下的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;监视一系列与你I/O操作相关的文件描述符（description)&lt;/li&gt;
&lt;li&gt;不停地向你汇报那些准备好I/O操作的文件描述符&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个设计优秀的reactor模式实现需要做到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;处理所有不同系统会出现的I/O事件&lt;/li&gt;
&lt;li&gt;提供优雅的抽象来帮助你在使用reactor时少花些心思去考虑它的存在&lt;/li&gt;
&lt;li&gt;提供你可以在抽象层外（treactor实现）使用的公共协议实现。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reactor特性&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用twisted.internet.pollreactor中的系统调用来poll 来代替select方法&lt;br /&gt;
from twited.internet import pollreactor&lt;br /&gt;
pollreactor.install()&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
reactor.run()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;transports:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Transports&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个Twisted的Transport代表一个可以收发字节的单条连接。对于我们的诗歌下载客户端而言，就是对一条TCP连接的抽象。&lt;/li&gt;
&lt;li&gt;ransport抽象可以代表任何这样的连接并为其代表的连接处理具体的异步I/O操作细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocols:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocols&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个具体的Twisted的Protocol的实现应该对应一个具体网络协议的实现，像FTP、IMAP或其它我们自己规定的协议。&lt;/li&gt;
&lt;li&gt;每一个Twisted的Protocols类实例都为一个具体的连接提供协议解析。&lt;/li&gt;
&lt;li&gt;Protocol实例是存储协议状态与间断性接收并累积数据的地方（由于我们是通过异步I/O方式以任意大小来接收数据的）。&lt;/li&gt;
&lt;li&gt;Protocol实例如何得知它为哪条连接服务呢？如果你阅读IProtocol定义会发现一个makeConnection函数。这是一个回调函数，Twisted会在调用它时传递给其一个也是仅有的一个参数，即就是Transport实例。这个Transport实例就代表Protocol将要使用的连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocol-factories:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocol Factories&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个连接需要一个自己的Portocol&lt;/li&gt;
&lt;li&gt;Protocol Factories一个新的连接制定一个合适的协议&lt;/li&gt;
&lt;li&gt;Protocol Factory就是Factory模式的一个具体实现。&lt;/li&gt;
&lt;li&gt;buildProtocol方法在每次被调用时返回一个新Protocol实例。它就是Twisted用来为新连接创建新Protocol实例的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;failure:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Failure&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果有异常出现的话，其能捕获Exception与跟踪栈。&lt;/li&gt;
&lt;li&gt;将一个Failure对象付给回调函数，我们就可以为以后的调试保存跟踪栈的信息了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关于回调:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;关于回调&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;激活errback是非常重要的。由于errback的功能与except块相同，因此用户需要确保它们的存在。他们并不可选项，而是必选项。&lt;/li&gt;
&lt;li&gt;不在错误的时间点激活回调与在正确的时间点激活回调同等重要。典型的用法是，callback与errback是互斥的即只能运行其中一个。&lt;/li&gt;
&lt;li&gt;使用回调函数的代码重构起来有些困难。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deferred-以让程序员在使用回调时更简便:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred-以让程序员在使用回调时更简便&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;

&lt;ol&gt;
&lt;li&gt;我们不能忽视errback，在任何异步编程的API中都需要它。Deferred支持errbacks。&lt;/li&gt;
&lt;li&gt;激活回调多次可能会导致很严重的问题。Deferred只能被激活一次，这就类似于同步编程中的try/except的处理方法。&lt;/li&gt;
&lt;li&gt;含有回调的程序在重构时相当困难。有了deferred，我们就通过修改回调链来重构程序。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;一个deferred有一个callback/errback对链，它们以添加到deferred中的顺序依次排列&lt;/li&gt;
&lt;li&gt;stage 0，即第一对errback/callbac，会在deferred激活时调用，具体调用那个看激活deferred的方式，若是通过.errback激活，则调用errback；同样若是通过.callback激活则调用callback。（这里的errback/callback实际是指通过addBoth添加的函数）&lt;/li&gt;
&lt;li&gt;如果stage N执行出现异常，则stage N+1的errback被调用，并且其参数即为stage N出现的异常&lt;/li&gt;
&lt;li&gt;同样，如果stage N成功，即没有抛出异常，则N+1的callback被调用，其第一个参数为stage N的返回值。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务器用ServerFactory而不是ClientFactory, 这是因为服务器是要被动地监听连接状态而不是像客户端一样去主动的创建。使用listenTCP方法.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deferred进阶:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred进阶&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个deferred的回调链中的一个回函数可以再返回了一个 deferred&lt;/li&gt;
&lt;li&gt;当内层deferrd被激活时，外层的deferred恢复其回调链的执行。当内层deferred回调执行成功，那么外层deferred会调用第N+1个callback回调。相反，如果内层deferred执行失败，那么外层deferred会调用第N+1个errback回调
&lt;img src=&#34;http://cuick.github.io/twisted/deferred-111.png&#34; alt=&#34;deferred&#34; title=&#34;xxx&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>