<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Twisteds on 崔程凯</title>
    <link>http://cuick.github.io/twisted/</link>
    <description>Recent content in Twisteds on 崔程凯</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 27 Feb 2016 22:17:23 +0800</lastBuildDate>
    <atom:link href="http://cuick.github.io/twisted/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Twisted学习笔记1</title>
      <link>http://cuick.github.io/twisted/101/</link>
      <pubDate>Sat, 27 Feb 2016 22:17:23 +0800</pubDate>
      
      <guid>http://cuick.github.io/twisted/101/</guid>
      <description>

&lt;h1 id=&#34;网络编程:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;网络编程&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;poll&lt;/li&gt;
&lt;li&gt;epoll&lt;/li&gt;
&lt;li&gt;greenlet&lt;/li&gt;
&lt;li&gt;gevent&lt;/li&gt;
&lt;li&gt;gevent是基于协程的高性能Python网络库，相比Twisted、Stackless等，gevent使用libev事件循环，因此速度很快、性能很好，使用greenlet提供高层的同步API，因此非常轻量。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elias.cn/Python/PyConcurrency&#34;&gt;http://www.elias.cn/Python/PyConcurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/yueguanghaidao/&#34;&gt;http://blog.csdn.net/yueguanghaidao/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;reactor:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Reactor&lt;/h1&gt;

&lt;h3 id=&#34;一个真正reactor模式的实现是需要实现循环独立抽象出来并具有如下的功能:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;一个真正reactor模式的实现是需要实现循环独立抽象出来并具有如下的功能：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;监视一系列与你I/O操作相关的文件描述符（description)&lt;/li&gt;
&lt;li&gt;不停地向你汇报那些准备好I/O操作的文件描述符&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;一个设计优秀的reactor模式实现需要做到:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;一个设计优秀的reactor模式实现需要做到：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;处理所有不同系统会出现的I/O事件&lt;/li&gt;
&lt;li&gt;提供优雅的抽象来帮助你在使用reactor时少花些心思去考虑它的存在&lt;/li&gt;
&lt;li&gt;提供你可以在抽象层外（treactor实现）使用的公共协议实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;reactor特性:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;reactor特性&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用twisted-internet-pollreactor中的系统调用来poll-来代替select方法:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;使用twisted.internet.pollreactor中的系统调用来poll 来代替select方法&lt;/h3&gt;

&lt;p&gt;from twited.internet import pollreactor&lt;br /&gt;
pollreactor.install()&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
reactor.run()&lt;/p&gt;

&lt;h1 id=&#34;twisted:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Twisted&lt;/h1&gt;

&lt;h3 id=&#34;注意点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;注意点：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在一个回调函数执行过程中，实际上Twisted的循环是被有效地阻塞在我们的代码上的。因此，因此我们应该确保回调函数不要浪费时间（尽快返回）。&lt;/li&gt;
&lt;li&gt;很多标准的Python方法没有办法转换为非阻塞方式。例如，os.system中的很多方法会在子进程完成前一直处于阻塞状态。这也就是它工作的方式。所以当你使用Twisted时，避开使用os.system。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;transports:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Transports&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个Twisted的Transport代表一个可以收发字节的单条连接。对于我们的诗歌下载客户端而言，就是对一条TCP连接的抽象。&lt;/li&gt;
&lt;li&gt;ransport抽象可以代表任何这样的连接并为其代表的连接处理具体的异步I/O操作细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocols:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocols&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个具体的Twisted的Protocol的实现应该对应一个具体网络协议的实现，像FTP、IMAP或其它我们自己规定的协议。&lt;/li&gt;
&lt;li&gt;每一个Twisted的Protocols类实例都为一个具体的连接提供协议解析。&lt;/li&gt;
&lt;li&gt;Protocol实例是存储协议状态与间断性接收并累积数据的地方（由于我们是通过异步I/O方式以任意大小来接收数据的）。&lt;/li&gt;
&lt;li&gt;Protocol实例如何得知它为哪条连接服务呢？如果你阅读IProtocol定义会发现一个makeConnection函数。这是一个回调函数，Twisted会在调用它时传递给其一个也是仅有的一个参数，即就是Transport实例。这个Transport实例就代表Protocol将要使用的连接。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>