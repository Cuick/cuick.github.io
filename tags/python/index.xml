<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on K&#39;s blog!</title>
    <link>http://cuick.github.io/tags/python/</link>
    <description>Recent content in Python on K&#39;s blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Apr 2016 15:07:49 +0800</lastBuildDate>
    <atom:link href="http://cuick.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>python基础-模块</title>
      <link>http://cuick.github.io/python/111_module/</link>
      <pubDate>Wed, 13 Apr 2016 15:07:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/111_module/</guid>
      <description>

&lt;h2 id=&#34;包:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;包&lt;/h2&gt;

&lt;p&gt;避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package1
├─ __init__.py
├── admin.py
├── models.py
├── tests.py
└─ views.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个包目录下面都会有一个&lt;strong&gt;init&lt;/strong&gt;.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。&lt;strong&gt;init&lt;/strong&gt;.py可以是空文件，也可以有Python代码，因为&lt;strong&gt;init&lt;/strong&gt;.py本身就是一个模块，而它的模块名就是mycompany&lt;/p&gt;

&lt;p&gt;可以有多级目录，组成多级层次的包结构。&lt;/p&gt;

&lt;h2 id=&#34;模块:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;模块&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在Python中，一个.py文件就称之为一个模块（Module）。

#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39; a test module &#39;

__author__ = &#39;Michael Liao&#39;

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print &#39;Hello, world!&#39;
    elif len(args)==2:
        print &#39;Hello, %s!&#39; % args[1]
    else:
        print &#39;Too many arguments!&#39;

if __name__==&#39;__main__&#39;:
    test()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量&lt;strong&gt;name&lt;/strong&gt;置为&lt;strong&gt;main&lt;/strong&gt;，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。&lt;/p&gt;

&lt;h2 id=&#34;使用模块:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;使用模块&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import sys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能&lt;/p&gt;

&lt;h3 id=&#34;别名:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;别名&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;try:
    import cStringIO as StringIO
except ImportError: # 导入失败会捕获到ImportError
    import StringIO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于Python是动态语言，函数签名一致接口就一样，因此，无论导入哪个模块后续代码都能正常工作&lt;/p&gt;

&lt;h2 id=&#34;第三方模块:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;第三方模块&lt;/h2&gt;

&lt;h3 id=&#34;安装:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Python有两个封装了setuptools的包管理工具：easy_install和pip。&lt;/p&gt;

&lt;h3 id=&#34;模块搜索路径:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;模块搜索路径&lt;/h3&gt;

&lt;p&gt;当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错&lt;/p&gt;

&lt;p&gt;Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中&lt;/p&gt;

&lt;h3 id=&#34;添加自己的搜索目录:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;添加自己的搜索目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法一：直接修改sys.path，添加要搜索的目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方法二：设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;future:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;future&lt;/h3&gt;

&lt;p&gt;Python提供了&lt;strong&gt;future&lt;/strong&gt;模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。&lt;/p&gt;

&lt;p&gt;果你想在Python 2.7的代码中直接使用Python 3.x的除法，可以通过&lt;strong&gt;future&lt;/strong&gt;模块的division实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from __future__ import division

print &#39;10 / 3 =&#39;, 10 / 3
print &#39;10.0 / 3 =&#39;, 10.0 / 3
print &#39;10 // 3 =&#39;, 10 // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 / 3 = 3.33333333333
10.0 / 3 = 3.33333333333
10 // 3 = 3
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python基础-面向对象</title>
      <link>http://cuick.github.io/python/112_oop/</link>
      <pubDate>Wed, 13 Apr 2016 15:07:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/112_oop/</guid>
      <description>

&lt;h3 id=&#34;访问限制:0589866b25f4e1e0a9df23909371bb14&#34;&gt;访问限制&lt;/h3&gt;

&lt;p&gt;在Python中，变量名类似 &lt;strong&gt;xxx&lt;/strong&gt; 的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用 &lt;strong&gt;name&lt;/strong&gt; 、&lt;strong&gt;score&lt;/strong&gt; 这样的变量名&lt;/p&gt;

&lt;p&gt;如果要让类内部属性不被外部访问，可以把属性的名称前加上两个下划线&lt;strong&gt;，在Python中，实例的变量名如果以&lt;/strong&gt;开头，就变成了一个私有变量（private）&lt;/p&gt;

&lt;p&gt;双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问&lt;strong&gt;name是因为Python解释器对外把&lt;/strong&gt;name变量改成了_Student&lt;strong&gt;name，所以，仍然可以通过_Student&lt;/strong&gt;name来访问__name变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Student(object):

def __init__(self, name, score):
    self.__name = name
    self.__score = score

def print_score(self):
    print &#39;%s: %s&#39; % (self.__name, self.__score)

&amp;gt;&amp;gt;&amp;gt; bart._Student__name
&#39;Bart Simpson&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是永远不要这么干&lt;/p&gt;

&lt;h3 id=&#34;获取对象信息:0589866b25f4e1e0a9df23909371bb14&#34;&gt;获取对象信息&lt;/h3&gt;

&lt;h4 id=&#34;type:0589866b25f4e1e0a9df23909371bb14&#34;&gt;type&lt;/h4&gt;

&lt;p&gt;判断对象类型&lt;/p&gt;

&lt;p&gt;所有类型本身的类型就是TypeType&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; type(int)==type(str)==types.TypeType
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;isinstance:0589866b25f4e1e0a9df23909371bb14&#34;&gt;isinstance&lt;/h4&gt;

&lt;p&gt;判断 一个对象是否是某种类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = Animal()
&amp;gt;&amp;gt;&amp;gt; d = Dog()
&amp;gt;&amp;gt;&amp;gt; h = Husky()

&amp;gt;&amp;gt;&amp;gt; isinstance(h, Husky)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子类对象是是父类的类型&lt;/p&gt;

&lt;p&gt;父类对象 不是 子类 的类型&lt;/p&gt;

&lt;p&gt;能用type()判断的基本类型也可以用isinstance()判断&lt;/p&gt;

&lt;p&gt;还可以判断一个变量是否是某些类型中的一种:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;a&#39;, (str, unicode))
True
&amp;gt;&amp;gt;&amp;gt; isinstance(u&#39;a&#39;, (str, unicode))
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dir:0589866b25f4e1e0a9df23909371bb14&#34;&gt;dir()&lt;/h4&gt;

&lt;p&gt;获得一个对象的所有属性和方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(&#39;ABC&#39;)
[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__getslice__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;_formatter_field_name_split&#39;, &#39;_formatter_parser&#39;, &#39;capitalize&#39;, &#39;center&#39;, &#39;count&#39;, &#39;decode&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdigit&#39;, &#39;islower&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&amp;gt;&amp;gt;&amp;gt; obj = MyObject()

&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; obj.x
9
&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
False
&amp;gt;&amp;gt;&amp;gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;
&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;
19
&amp;gt;&amp;gt;&amp;gt; obj.y # 获取属性&#39;y&#39;
19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果试图获取不存在的属性，会抛出AttributeError的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;z&#39;) # 获取属性&#39;z&#39;
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以传入一个default参数，如果属性不存在，就返回默认值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404
404
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以获得对象的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;
&amp;lt;bound method MyObject.power of &amp;lt;__main__.MyObject object at 0x108ca35d0&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fn = getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn
&amp;gt;&amp;gt;&amp;gt; fn # fn指向obj.power
&amp;lt;bound method MyObject.power of &amp;lt;__main__.MyObject object at 0x108ca35d0&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fn() # 调用fn()与调用obj.power()是一样的
81
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;动态添加属性:0589866b25f4e1e0a9df23909371bb14&#34;&gt;动态添加属性&lt;/h3&gt;

&lt;p&gt;定义class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Student(object):
...     pass
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绑定属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = Student()
&amp;gt;&amp;gt;&amp;gt; s.name = &#39;Michael&#39; # 动态给实例绑定一个属性
&amp;gt;&amp;gt;&amp;gt; print s.name
Michael
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给一个实例绑定方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&amp;gt;&amp;gt;&amp;gt; from types import MethodType
&amp;gt;&amp;gt;&amp;gt; s.set_age = MethodType(set_age, s, Student) # 给实例绑定一个方法
&amp;gt;&amp;gt;&amp;gt; s.set_age(25) # 调用实例方法
&amp;gt;&amp;gt;&amp;gt; s.age # 测试结果
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给class绑定方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def set_score(self, score):
...     self.score = score
...
&amp;gt;&amp;gt;&amp;gt; Student.set_score = MethodType(set_score, None, Student)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给实例绑定方法后其他的实例不能使用
给类绑定方法后所有的实例都可以使用&lt;/p&gt;

&lt;p&gt;动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现&lt;/p&gt;

&lt;h4 id=&#34;slots:0589866b25f4e1e0a9df23909371bb14&#34;&gt;&lt;strong&gt;slots&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Python允许在定义class的时候，定义一个特殊的&lt;strong&gt;slots&lt;/strong&gt;变量，来限制该class能添加的属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Student(object):
...     __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称
...

&amp;gt;&amp;gt;&amp;gt; s = Student() # 创建新的实例
&amp;gt;&amp;gt;&amp;gt; s.name = &#39;Michael&#39; # 绑定属性&#39;name&#39;
&amp;gt;&amp;gt;&amp;gt; s.age = 25 # 绑定属性&#39;age&#39;
&amp;gt;&amp;gt;&amp;gt; s.score = 99 # 绑定属性&#39;score&#39;
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;slots&lt;/strong&gt;定义的属性仅对当前类起作用，对继承的子类是不起作用的&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python-函数式编程</title>
      <link>http://cuick.github.io/python/110_fp/</link>
      <pubDate>Tue, 12 Apr 2016 15:58:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/110_fp/</guid>
      <description>

&lt;h2 id=&#34;关于函数式编程:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;关于函数式编程&lt;/h2&gt;

&lt;p&gt;函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。&lt;/p&gt;

&lt;p&gt;而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算&lt;/p&gt;

&lt;p&gt;越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言&lt;/p&gt;

&lt;p&gt;函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。&lt;/p&gt;

&lt;p&gt;函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！&lt;/p&gt;

&lt;p&gt;Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。&lt;/p&gt;

&lt;h2 id=&#34;高阶函数-higher-order-function:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;高阶函数 Higher-order function&lt;/h2&gt;

&lt;h4 id=&#34;什么是:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;什么是&lt;/h4&gt;

&lt;p&gt;把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。&lt;/p&gt;

&lt;h4 id=&#34;map-reduce:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;map/reduce&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def f(x):
...     return x * x
...
&amp;gt;&amp;gt;&amp;gt; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def fn(x, y):
...     return x * 10 + y
...
&amp;gt;&amp;gt;&amp;gt; reduce(fn, [1, 3, 5, 7, 9])
13579

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;filter:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;filter&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; def a(b):
....     return b&amp;gt;5
....
&amp;gt;&amp;gt;&amp;gt;&amp;gt; b = [1,2,3,6,7,8]
&amp;gt;&amp;gt;&amp;gt;&amp;gt; filter(a,b)
[6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sorted:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;sorted&lt;/h4&gt;

&lt;p&gt;sorted()函数可以对list进行排序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;返回函数:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;返回函数&lt;/h2&gt;

&lt;p&gt;一个函数可以返回一个计算结果，也可以返回一个函数。&lt;/p&gt;

&lt;p&gt;返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。&lt;/p&gt;

&lt;h4 id=&#34;闭包:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def make_addr(addend):
    def addr(augend):
        return augend + addend
    return addr

p = make_addr(23)
q = make_addr(42)

print p(10)
print q(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种返回的函数带有外部函数的参数 的 函数，属于闭包函数&lt;/p&gt;

&lt;h2 id=&#34;匿名函数:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;匿名函数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lambda x: x * x&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关键字lambda表示匿名函数，冒号前面的x表示函数参数。&lt;/p&gt;

&lt;p&gt;匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。&lt;/p&gt;

&lt;p&gt;用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突&lt;/p&gt;

&lt;p&gt;匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数&lt;/p&gt;

&lt;h2 id=&#34;装饰器-decorator:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;装饰器 Decorator&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;decorator就是一个返回函数的高阶函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def log(func):
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&#39;2015-3-25&#39;)

&amp;gt;&amp;gt; now()
call now():
2015-3-25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的装饰器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者针对带参数的decorator：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在面向对象（OOP）的设计模式中，decorator被称为装饰模式&lt;/p&gt;

&lt;h2 id=&#34;偏函数-partial-function:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;偏函数 Partial function&lt;/h2&gt;

&lt;p&gt;functools模块的partial函数&lt;/p&gt;

&lt;p&gt;当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。&lt;/p&gt;

&lt;p&gt;普通使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;12345&#39;, base=8)
5349
&amp;gt;&amp;gt;&amp;gt; int(&#39;12345&#39;, 16)
74565
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用默认参数实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def int2(x, base=2):
    return int(x, base)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;偏函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import functools
&amp;gt;&amp;gt;&amp;gt; int2 = functools.partial(int, base=2)
&amp;gt;&amp;gt;&amp;gt; int2(&#39;1000000&#39;)
64
&amp;gt;&amp;gt;&amp;gt; int2(&#39;1010101&#39;)
85
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python-特性(切片、迭代...)</title>
      <link>http://cuick.github.io/python/109_special/</link>
      <pubDate>Mon, 11 Apr 2016 15:58:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/109_special/</guid>
      <description>

&lt;h2 id=&#34;切片:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;切片&lt;/h2&gt;

&lt;p&gt;取一个list或tuple的部分元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果第一个索引是0，还可以省略L[:3]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;倒数第一个元素的索引是-1。L[-2:-1]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;L[:]就可以原样复制一个list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串&amp;rsquo;xxx&amp;rsquo;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;L[:10:2],前10个数，每两个取一个&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;迭代:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;迭代&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样&lt;/li&gt;

&lt;li&gt;&lt;p&gt;判断一个对象是可迭代对象用collections模块的Iterable进行判断&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Iterable
&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代
True
&amp;gt;&amp;gt;&amp;gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&amp;gt;&amp;gt;&amp;gt; isinstance(123, Iterable) # 整数是否可迭代
False
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):
...     print(i, value)
...
0 A
1 B
2 C
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;列表生成式:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;列表生成式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;range(3)  [0,1,2]&lt;/li&gt;
&lt;li&gt;[x * x for x in range(1, 11)]  生成[1*1,2*2 &amp;hellip; 11*11]&lt;/li&gt;
&lt;li&gt;[x * x for x in range(1, 11) if x % 2 == 0] 偶数的平方的列表&lt;/li&gt;

&lt;li&gt;&lt;p&gt;两层循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在python3.x里range生成的是一个迭代对象而不是list，要想生成list需要list(range(n))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;生成器:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;生成器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列表元素可以按照某种算法推算出来，我们是否可以在循环的过程中不断推算出后续的元素,这样就不必创建完整的list，从而节省大量的空间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这种一边循环一边计算的机制，称为 &lt;em&gt;生成器&lt;/em&gt; （Generator）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建生成器：把一个列表生成式的[]改成()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = [x * x for x in range(10)]
&amp;gt;&amp;gt;&amp;gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&amp;gt;&amp;gt;&amp;gt; g = (x * x for x in range(10))
&amp;gt;&amp;gt;&amp;gt; g
&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x104feab40&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获得每个元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g.next()
0
&amp;gt;&amp;gt;&amp;gt; g.next()
1
...
&amp;gt;&amp;gt;&amp;gt; g.next()
64
&amp;gt;&amp;gt;&amp;gt; g.next()
81
&amp;gt;&amp;gt;&amp;gt; g.next()
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
  StopIteration
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为generator也是可迭代对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g = (x * x for x in range(10))
&amp;gt;&amp;gt;&amp;gt; for n in g:
...     print n
...
0
1
4
9
16
25
36
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建了一个generator后，很少调用next()方法，而是通过for循环来迭代它&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def fib(max):
    n, a, b = 0, 0, 1
    while n &amp;lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;迭代器:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;迭代器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;可作用于for循环的对象都是可迭代对象Iterable类型；&lt;/li&gt;
&lt;li&gt;可作用于next()函数的对象都是迭代器Iterator类型，它们表示一个惰性计算的序列；&lt;/li&gt;
&lt;li&gt;集合数据类型如list、dict、str等是可迭代对象Iterable但不是迭代器Iterator，不过可以通过iter()函数获得一个迭代器Iterator对象。&lt;/li&gt;
&lt;li&gt;生成器generator都是迭代器Iterator&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>python基础-函数</title>
      <link>http://cuick.github.io/python/108_fun/</link>
      <pubDate>Sun, 10 Apr 2016 15:07:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/108_fun/</guid>
      <description>

&lt;h2 id=&#34;所有内置函数:de303522e70934a82875d78047200a03&#34;&gt;所有内置函数&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html&#34;&gt;https://docs.python.org/3/library/functions.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;return:de303522e70934a82875d78047200a03&#34;&gt;return&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;函数可以返回多个值。&lt;/li&gt;
&lt;li&gt;但其实这只是一种假象，Python函数返回的仍然是单一值,一个tuple&lt;/li&gt;
&lt;li&gt;* 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参数:de303522e70934a82875d78047200a03&#34;&gt;参数&lt;/h2&gt;

&lt;h4 id=&#34;位置参数:de303522e70934a82875d78047200a03&#34;&gt;位置参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def a(x, y):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;默认参数:de303522e70934a82875d78047200a03&#34;&gt;默认参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def a(x=1):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;一定要注意默认参数的默认值不要设置为可变对象（比如 list dict 等）&lt;/li&gt;
&lt;li&gt;可以用None等代替&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;可变参数:de303522e70934a82875d78047200a03&#34;&gt;可变参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; calc(*nums)
14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*nums表示把nums这个list的所有元素作为可变参数传进去。&lt;/p&gt;

&lt;h4 id=&#34;关键字参数:de303522e70934a82875d78047200a03&#34;&gt;关键字参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def person(name, age, **kw):
    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, **extra)
name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以先组装出一个dict，在传入的参数前面加**，把该dict转换为关键字参数传进去&lt;/p&gt;

&lt;h4 id=&#34;命名关键字参数-只有python3-x版本有:de303522e70934a82875d78047200a03&#34;&gt;命名关键字参数(只有python3.x版本有)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def person(name, age, *, city, job):
    print(name, age, city, job)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命名关键字参数时，要特别注意，*不是参数，而是特殊分隔符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)
Jack 24 Beijing Engineer
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参数组合:de303522e70934a82875d78047200a03&#34;&gt;参数组合&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def f1(a, b=1, *, c, **kw):
    print(a,b,c,kw)

def f2(a, b=0, *args, **kw):
    print(a,b,args,kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;除了可变参数无法和命名关键字参数混合,其他均可组合使用&lt;/li&gt;
&lt;li&gt;参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;总结:de303522e70934a82875d78047200a03&#34;&gt;总结&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可变参数，函数内转为tuple，&lt;/li&gt;
&lt;li&gt;关键字参数，函数内转为dict&lt;/li&gt;
&lt;li&gt;调用时，可在变量前加*，把list或者tuple作为可变参数传入函数内&lt;/li&gt;
&lt;li&gt;调用时，可在变量前加**，把dict作为关键字参数传入函数内&lt;/li&gt;
&lt;li&gt;命名关键字参数在 &amp;gt;3.5 的版本中才有&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>python-赋值、引用、拷贝、作用域</title>
      <link>http://cuick.github.io/python/107_copy/</link>
      <pubDate>Thu, 07 Apr 2016 14:55:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/107_copy/</guid>
      <description>

&lt;h2 id=&#34;赋值-引用-浅复制-深复制:8d37479f728103ff01e750a3599e3a2e&#34;&gt;赋值 引用 浅复制 深复制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;python 中赋值语句总是建立对象的引用值，而不是复制对象。因此，python 变量更像是指针，而不是数据存储区域&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; values = [0, 1, 2]
&amp;gt;&amp;gt;&amp;gt; values[1] = values
&amp;gt;&amp;gt;&amp;gt; values
[0, [...], 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并非我预想de:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0, [0, 1, 2], 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要达到你所需要的效果，即得到 [0, [0, 1, 2], 2] 这个对象，你不能直接将 values[1] 指向 values 引用的对象本身，需要：&lt;/p&gt;

&lt;p&gt;所以你需要执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;values[1] = values[:]  #生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;values[:] 复制操作是所谓的「浅复制」(shallow copy)，当列表对象有嵌套的时候也会产生出乎意料的错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = [0, [1, 2], 3]
b = a[:]
a[0] = 8
a[1][1] = 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确答案是 a 为 [8, [1, 9], 3]，b 为 [0, [1, 9], 3]
b的第二个元组也变化了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;正确的复制嵌套元素的方法是进行「深复制」(deep copy)，方法是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy

 a = [0, [1, 2], 3]
 b = copy.deepcopy(a)
 a[0] = 8
 a[1][1] = 9
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;引用-and-复制:8d37479f728103ff01e750a3599e3a2e&#34;&gt;引用 and 复制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;没有限制条件的分片表达式（L[:]）能够复制序列，但此法只能浅层复制。&lt;/li&gt;
&lt;li&gt;字典 copy 方法，D.copy() 能够复制字典，但此法只能浅层复制&lt;/li&gt;
&lt;li&gt;有些内置函数，例如 list，能够生成拷贝 list(L),浅复制&lt;/li&gt;
&lt;li&gt;copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy&lt;/li&gt;
&lt;li&gt;对于不可变对象和可变对象来说，浅复制都是复制的引用，只是因为复制不变对象和复制不变对象的引用是等效的（因为对象不可变，当改变时会新建对象重新赋值）。所以看起来浅复制只复制不可变对象（整数，实数，字符串等），对于可变对象，浅复制其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了另一个标签而已。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-b-与-a-a-b:8d37479f728103ff01e750a3599e3a2e&#34;&gt;a+=b 与 a=a+b&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;L = [1, 2]
M = L
L = L + [3, 4]
print L, M
print &amp;quot;-------------------&amp;quot;
L = [1, 2]
M = L
L += [3, 4]
print L, M

[1, 2, 3, 4] [1, 2]
-------------------
[1, 2, 3, 4] [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;例子中两种操作结果不同&lt;/li&gt;
&lt;li&gt;x = x + y 定义一个x，合并x与y，赋值给x&lt;/li&gt;
&lt;li&gt;x += y 不生成新对象，只是把y添加到x内存块末尾，性能相比来要好&lt;/li&gt;
&lt;li&gt;x y 都为list时， +自动调用extend进行合并运算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python-从-2-x-到-3-x-语句变函数引发的变量作用域问题:8d37479f728103ff01e750a3599e3a2e&#34;&gt;python 从 2.x 到 3.x，语句变函数引发的变量作用域问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;def test():
    a = False
    exec (&amp;quot;a = True&amp;quot;)
    print (&amp;quot;a = &amp;quot;, a)
test()

b = False
exec (&amp;quot;b = True&amp;quot;)
print (&amp;quot;b = &amp;quot;, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同版本下结果分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.x：
a =  True
b =  True

3.x：
a =  False
b =  True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因：
在3.x版本中exec 由语句变成函数了，而在函数中变量默认都是局部的，也就是说
你所见到的两个 a，是两个不同的变量，分别处于不同的命名空间中，而不会冲突。&lt;/p&gt;

&lt;p&gt;兼容方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test():
    a = False
    ldict = locals()
    exec(&amp;quot;a=True&amp;quot;,globals(),ldict)
    a = ldict[&#39;a&#39;]
    print(a)

test()

b = False
exec(&amp;quot;b = True&amp;quot;, globals())
print(&amp;quot;b = &amp;quot;, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-变量作用域及其陷阱:8d37479f728103ff01e750a3599e3a2e&#34;&gt;python 变量作用域及其陷阱&lt;/h2&gt;

&lt;h3 id=&#34;可变与不可变对象:8d37479f728103ff01e750a3599e3a2e&#34;&gt;可变与不可变对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不可变对象包括int，float，long，str，tuple等&lt;/li&gt;
&lt;li&gt;可变对象包括list，set，dict等&lt;/li&gt;
&lt;li&gt;不可变指的是值的不可变。对于不可变类型的变量，如果要更改变量，则会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收&lt;/li&gt;
&lt;li&gt;不可变的类型可以计算hash值，可以作为字典的key&lt;/li&gt;
&lt;li&gt;可变类型数据对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变，但区域会变长或者变短。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;函数值传递:8d37479f728103ff01e750a3599e3a2e&#34;&gt;函数值传递&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;def func_int(a):
    a += 4

def func_list(a_list):
    a_list[0] = 4

t = 0
func_int(t)
print t
# output: 0

t_list = [1, 2, 3]
func_list(t_list)
print t_list
# output: [4, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;引起上面现象的原因:对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。&lt;/li&gt;
&lt;li&gt;在函数参数传递的时候，Python其实就是把参数里传入的变量对应的对象的引用依次赋值给对应的函数内部变量&lt;/li&gt;
&lt;li&gt;例子中func_int中的局部变量&amp;rdquo;a&amp;rdquo;其实是全部变量&amp;rdquo;t&amp;rdquo;所指向对象的另一个引用，由于整数对象是不可变的，所以当func_int对变量&amp;rdquo;a&amp;rdquo;进行修改的时候，实际上是将局部变量&amp;rdquo;a&amp;rdquo;指向到了整数对象&amp;rdquo;1&amp;rdquo;。所以很明显，func_list修改的是一个可变的对象，局部变量&amp;rdquo;a&amp;rdquo;和全局变量&amp;rdquo;t_list&amp;rdquo;指向的还是同一个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;局部变量-全局变量:8d37479f728103ff01e750a3599e3a2e&#34;&gt;局部变量 全局变量&lt;/h3&gt;

&lt;p&gt;例一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = &#39;foo&#39;
d = {&#39;a&#39;:1}
def f():
    s = &#39;bar&#39;
    d[&#39;b&#39;] = 2
f()
print s  # foo
print d  # {&#39;a&#39;: 1, &#39;b&#39;: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在s = &amp;lsquo;bar&amp;rsquo;这句中，它是“有歧义的“，因为它既可以是表示引用全局变量s，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global&lt;/li&gt;
&lt;li&gt;在d[&amp;lsquo;b&amp;rsquo;]=2这句中，它是“明确的”，因为如果把d当作是局部变量的话，它会报KeyError，所以它只能是引用全局的d,故不需要多此一举显式声明global&lt;/li&gt;
&lt;li&gt;止dict不需要global，所有”明确的“东西都不需要global&lt;/li&gt;
&lt;li&gt;int类型str类型之类的不可变对象，每一次操作就重建新的对象，他们只有一种修改方法，即x = y， 恰好这种修改方法同时也是创建变量的方法，所以产生了歧义，不知道是要修改还是创建。而dict/list/对象等可变对象，操作不会重建对象，可以通过dict[&amp;lsquo;x&amp;rsquo;]=y或list.append()之类的来修改，跟创建变量不冲突，不产生歧义，所以都不用显式global。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例二&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list_a = []
def a():
    list_a = [1]      ## 语句1
a()
print list_a    # []
print &amp;quot;======================&amp;quot;
list_b = []
def b():
    list_b.append(1)    ## 语句2
b()
print list_b    # [1]
print &#39;=======================&#39;
list_c = [1]
def c():
    list_c[0] = 3      ## 语句3
c()
print list_c    # [3]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;语句1有歧义所以python规定是定义了一个局部变量。&lt;/li&gt;
&lt;li&gt;语句2与语句3没有歧义，是修改了全局变量，不然会是报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;永远不要用可变的默认参数:8d37479f728103ff01e750a3599e3a2e&#34;&gt;永远不要用可变的默认参数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;def foo(a, b, c=[]):
# append to c
# do some more stuff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法，每次调用foo，用的都是同一个引用，同一个地方修改了c的值，其他地方跟着变。非常可怕！！！！！！！&lt;/p&gt;

&lt;p&gt;要修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def foo(a, b, c=None):
    if c is None:
        c = []
    # append to c
    # do some more stuff
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python基础-list tuple set</title>
      <link>http://cuick.github.io/python/106_list_tuple_set/</link>
      <pubDate>Thu, 07 Apr 2016 14:55:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/106_list_tuple_set/</guid>
      <description>

&lt;h2 id=&#34;tuple-元组:9fbbb2834f2223c20142fe491c70f5c4&#34;&gt;tuple 元组&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;要定义一个只有1个元素的tuple，如果你这么定义&lt;code&gt;a = (1)&lt;/code&gt;,
定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。
只有1个元素的tuple定义时必须加一个逗号,，来消除歧义,&lt;code&gt;a=(1,)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tuple所谓的“不变”是说，tuple的每个元素，指向永远不变&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;list-列表:9fbbb2834f2223c20142fe491c70f5c4&#34;&gt;list 列表&lt;/h2&gt;

&lt;h2 id=&#34;set-集合:9fbbb2834f2223c20142fe491c70f5c4&#34;&gt;set 集合&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s2 = set([2, 3, 4])
&amp;gt;&amp;gt;&amp;gt; s1 &amp;amp; s2
set([2, 3])
&amp;gt;&amp;gt;&amp;gt; s1 | s2
set([1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>python基础-字符串和编码</title>
      <link>http://cuick.github.io/python/105_string/</link>
      <pubDate>Thu, 07 Apr 2016 09:55:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/105_string/</guid>
      <description>

&lt;h2 id=&#34;字符串:a23880f8b35e46659c516e699a542eed&#34;&gt;字符串&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;字符串是以单引号&lt;code&gt;&#39;&lt;/code&gt;或双引号&lt;code&gt;&amp;quot;&lt;/code&gt;括起来的任意文本，比如&lt;code&gt;&#39;abc&#39;&lt;/code&gt;，&lt;code&gt;&amp;quot;xyz&amp;quot;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果字符串内部既包含&lt;code&gt;&#39;&lt;/code&gt;又包含&lt;code&gt;&amp;quot;&lt;/code&gt;怎么办？可以用转义字符\来标识&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;I\&#39;m \&amp;quot;OK\&amp;quot;!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I&#39;m &amp;quot;OK&amp;quot;!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转义字符\可以转义很多字符，比如&lt;code&gt;\n&lt;/code&gt;表示换行，&lt;code&gt;\t&lt;/code&gt;表示制表符，字符\本身也要转义，所以&lt;code&gt;\\&lt;/code&gt;表示的字符就是\，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(&#39;\\\t\\&#39;)
\       \
&amp;gt;&amp;gt;&amp;gt; print(r&#39;\\\t\\&#39;)
\\\t\\
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&lt;code&gt;&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;的格式表示多行内容&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多行字符串&lt;code&gt;&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;还可以在前面加上r使用&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;编码:a23880f8b35e46659c516e699a542eed&#34;&gt;编码&lt;/h2&gt;

&lt;h4 id=&#34;ascii-unicode和utf-8的关系:a23880f8b35e46659c516e699a542eed&#34;&gt;ASCII、Unicode和UTF-8的关系&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。&lt;/li&gt;
&lt;li&gt;处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去,日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里,
各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。&lt;/li&gt;
&lt;li&gt;Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。
字母A用ASCII编码是十进制的65，二进制的01000001；&lt;/p&gt;

&lt;p&gt;字符0用ASCII编码是十进制的48，二进制的00110000，注意字符&amp;rsquo;0&amp;rsquo;和整数0是不同的；&lt;/p&gt;

&lt;p&gt;汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unicode编码转化为“可变长编码”的UTF-8编码。
UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。
如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;计算机系统通用的字符编码工作方式:a23880f8b35e46659c516e699a542eed&#34;&gt;计算机系统通用的字符编码工作方式&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;/li&gt;
&lt;li&gt;用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件&lt;/li&gt;
&lt;li&gt;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;python字符串-python2-7:a23880f8b35e46659c516e699a542eed&#34;&gt;python字符串(python2.7)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Python只支持ASCII编码&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u&amp;rsquo;&amp;hellip;&amp;lsquo;表示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print u&#39;中文&#39;
中文
&amp;gt;&amp;gt;&amp;gt; u&#39;中&#39;
u&#39;\u4e2d
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串&amp;rsquo;xxx&amp;rsquo;虽然是ASCII编码，但也可以看成是UTF-8编码，而u&amp;rsquo;xxx&amp;rsquo;则只能是Unicode编码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把u&amp;rsquo;xxx&amp;rsquo;转换为UTF-8编码的&amp;rsquo;xxx&amp;rsquo;用encode(&amp;lsquo;utf-8&amp;rsquo;)方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u&#39;ABC&#39;.encode(&#39;utf-8&#39;)
&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; u&#39;中文&#39;.encode(&#39;utf-8&#39;)
&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由unicode转化为指定的编码用encode。由指定编码 解码为 unicode 用decode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;英文字符转换后表示的UTF-8的值和Unicode值相等（但占用的存储空间不同），而中文字符转换后1个Unicode字符将变为3个UTF-8字符，\xe4就是其中一个字节，因为它的值是228，没有对应的字母可以显示，所以以十六进制显示字节的数值。len()函数可以返回字符串的长度&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；&lt;/p&gt;

&lt;p&gt;第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python3字符串是以Unicode编码的&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;格式化:a23880f8b35e46659c516e699a542eed&#34;&gt;格式化&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;采用的格式化方式和C语言是一致的，用%实现&lt;/li&gt;
&lt;li&gt;有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常见的占位符有：&lt;/p&gt;

&lt;p&gt;%d  整数
%f  浮点数
%s  字符串
%x  十六进制整数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;格式化整数和浮点数还可以指定是否补0和整数与小数的位数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &#39;%2d-%02d&#39; % (3, 1)
&#39; 3-01&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;%.2f&#39; % 3.1415926
&#39;3.14&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于Unicode字符串，用法完全一样，但最好确保替换的字符串也是Unicode字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u&#39;Hi, %s&#39; % u&#39;Michael&#39;
u&#39;Hi, Michael&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串里面的%是一个普通字符的时候就需要转义，用%%来表示一个%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &#39;growth rate: %d %%&#39; % 7
&#39;growth rate: 7 %&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python当然也支持其他编码方式，比如把Unicode编码成GB2312&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u&#39;中文&#39;.encode(&#39;gb2312&#39;)
&#39;\xd6\xd0\xce\xc4&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有特殊业务要求，请牢记仅使用Unicode和UTF-8这两种编码方式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Python 3.x版本中，把&amp;rsquo;xxx&amp;rsquo;和u&amp;rsquo;xxx&amp;rsquo;统一成Unicode编码，即写不写前缀u都是一样的&lt;/p&gt;

&lt;p&gt;由于Python3.x的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。&lt;/p&gt;

&lt;p&gt;Python3.x对bytes类型的数据用带b前缀的单引号或双引号表示：b&amp;rsquo;xxx&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>time计算日周月时间戳</title>
      <link>http://cuick.github.io/python/104_time/</link>
      <pubDate>Wed, 06 Apr 2016 20:48:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/104_time/</guid>
      <description>&lt;p&gt;计算自然周第一天、自然月第一天和每天的凌晨时间戳&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time

def get_day_begin(ts = time.time(),N = 0):
&amp;quot;&amp;quot;&amp;quot;
N为0时获取时间戳ts当天的起始时间戳，N为负数时前数N天，N为正数是后数N天
&amp;quot;&amp;quot;&amp;quot;

 return int(time.mktime(time.strptime(time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(ts)),&#39;%Y-%m-%d&#39;))) + 86400*N

def get_week_begin(ts = time.time(),N = 0):
&amp;quot;&amp;quot;&amp;quot;
N为0时获取时间戳ts当周的开始时间戳，N为负数时前数N周，N为整数是后数N周，此函数将周一作为周的第一天
&amp;quot;&amp;quot;&amp;quot;
 w = int(time.strftime(&#39;%w&#39;,time.localtime(ts)))
 return get_day_begin(int(ts - (w-1)*86400)) + N*604800

def get_month_begin(ts = time.time(),N = 0):
&amp;quot;&amp;quot;&amp;quot;
N为0时获取时间戳ts当月的开始时间戳，N为负数前数N月，N为正数后数N月
&amp;quot;&amp;quot;&amp;quot;
 month_day = {1:31,3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}
 cur_y,cur_m,cur_d = [int(x) for x in time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(ts)).split(&#39;-&#39;)]
 if (cur_y%4 == 0 and cur_y%100 != 0) or cur_y%400 == 0:
 month_day[2] = 29
else:
 month_day[2] = 28
 t = get_day_begin(ts) - (cur_d-1)*86400
 real_month = N + cur_m
 if real_month == cur_m:
 return t
 if N &amp;gt; 0:
 if real_month &amp;lt;= 12:
 for x in xrange(cur_m,real_month):
 t += month_day[x]*86400
 if real_month &amp;gt; 12:
 for x in xrange(cur_m,13):
 t += month_day[x]*86400
 t = get_month_begin(t,real_month - 13)
 if N &amp;lt; 0:
 if real_month &amp;gt;= 1:
 for x in xrange(real_month,cur_m):
 t -= month_day[x]*86400
 if real_month &amp;lt; 1:
 for x in xrange(1,cur_m):
 t -= month_day[x]*86400
 t -= month_day[12]*86400
 t = get_month_begin(t,real_month)
 return t

if __name__ ==&amp;quot;__main__&amp;quot;:
 t = time.time()
 print time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(get_day_begin(t,1)))
 print time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(get_week_begin(t,-2)))
 print time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(get_month_begin(t,-3)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Twisted-测试</title>
      <link>http://cuick.github.io/twisted/102/</link>
      <pubDate>Sun, 20 Mar 2016 22:03:23 +0800</pubDate>
      
      <guid>http://cuick.github.io/twisted/102/</guid>
      <description>

&lt;h1 id=&#34;测试:b66e25cf931c5c75968256c4152b6090&#34;&gt;测试&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>python基础-字典删除元素</title>
      <link>http://cuick.github.io/python/103_dict/</link>
      <pubDate>Sun, 20 Mar 2016 17:57:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/103_dict/</guid>
      <description>

&lt;h2 id=&#34;python-字典删除元素clear-pop-popitem:038858a3f82cf4ccbb0e60712917b653&#34;&gt;Python 字典删除元素clear、pop、popitem&lt;/h2&gt;

&lt;h3 id=&#34;clear:038858a3f82cf4ccbb0e60712917b653&#34;&gt;clear()&lt;/h3&gt;

&lt;p&gt;clear()方法是用来清除字典中的所有数据，因为是原地操作，所以返回None（也可以理解为没有返回值）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x[&#39;name&#39;] = &#39;lili&#39;
&amp;gt;&amp;gt;&amp;gt; x[&#39;age&#39;] = 20
&amp;gt;&amp;gt;&amp;gt; x
{&#39;age&#39;: 20, &#39;name&#39;: &#39;lili&#39;}
&amp;gt;&amp;gt;&amp;gt; returned_value = x.clear()
&amp;gt;&amp;gt;&amp;gt; x
{ }
&amp;gt;&amp;gt;&amp;gt; print returned_value
None

字典的clear()方法有什么特点：
&amp;gt;&amp;gt;&amp;gt; f = {&#39;key&#39;:&#39;value&#39;}
&amp;gt;&amp;gt;&amp;gt; a = f
&amp;gt;&amp;gt;&amp;gt; a
{&#39;key&#39;: &#39;value&#39;}
&amp;gt;&amp;gt;&amp;gt; f.clear()
&amp;gt;&amp;gt;&amp;gt; f
{}
&amp;gt;&amp;gt;&amp;gt; a
{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当原字典被引用时，想清空原字典中的元素，用clear()方法，a字典中的元素也同时被清除了。&lt;/p&gt;

&lt;h3 id=&#34;pop:038858a3f82cf4ccbb0e60712917b653&#34;&gt;pop()&lt;/h3&gt;

&lt;p&gt;移除字典数据pop()方法的作用是：删除指定给定键所对应的值，返回这个值并从字典中把它移除。注意字典pop()方法与列表pop()方法作用完全不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = {&#39;a&#39;:1,&#39;b&#39;:2}
&amp;gt;&amp;gt;&amp;gt; x.pop(&#39;a&#39;)
1
&amp;gt;&amp;gt;&amp;gt; x
{&#39;b&#39;: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;popitem:038858a3f82cf4ccbb0e60712917b653&#34;&gt;popitem()&lt;/h3&gt;

&lt;p&gt;字典popitem()方法作用是：随机返回并删除字典中的一对键和值（项）。为什么是随机删除呢？因为字典是无序的，没有所谓的“最后一项”或是其它顺序。在工作时如果遇到需要逐一删除项的工作，用popitem()方法效率很高。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x
{&#39;url&#39;: &#39;aaa&#39;, &#39;title&#39;: &#39;bbb&#39;}
&amp;gt;&amp;gt;&amp;gt; x.popitem()
(&#39;url&#39;, &#39;aaa&#39;)
&amp;gt;&amp;gt;&amp;gt; x
{&#39;title&#39;: &#39;bbb&#39;}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>线程安全与GIL</title>
      <link>http://cuick.github.io/python/102_gil/</link>
      <pubDate>Sat, 19 Mar 2016 21:15:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/102_gil/</guid>
      <description>

&lt;h2 id=&#34;引入:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;引入&lt;/h2&gt;

&lt;p&gt;多核时代到来。为了更好利用多核，就要讲到进程与线程，区别在于是否共享资源，前者是独立的后这是共享的。&lt;br /&gt;
多线程环境最大的问题就是资源的竞争 死锁 数据修改。
于是就有了线程安全的问题。&lt;/p&gt;

&lt;h2 id=&#34;线程安全:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;线程安全&lt;/h2&gt;

&lt;p&gt;在多线程的环境下, 线程安全能够保证多个线程同时执行时程序依旧运行正确, 而且要保证对于共享的数据,可以由多个线程存取,但是同一时刻只能有一个线程进行存取.&lt;/p&gt;

&lt;p&gt;加锁可以保证存取操作的唯一性, 从而保证同一时刻只有一个线程对共享数据存取.&lt;/p&gt;

&lt;p&gt;通常加锁也有2种不同的粒度的锁:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fine-grained(所谓的细粒度), 那么程序员需要自行地加,解锁来保证线程安全&lt;/li&gt;
&lt;li&gt;coarse-grained(所谓的粗粒度), 那么语言层面本身维护着一个全局的锁机制,用来保证线程安全&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前一种方式比较典型的是 java, Jython 等, 后一种方式比较典型的是 CPython (即Python).&lt;/p&gt;

&lt;p&gt;Python中的全局锁机制,便是 GIL (Global Interpreter Lock)&lt;/p&gt;

&lt;h2 id=&#34;什么是gil:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;什么是GIL&lt;/h2&gt;

&lt;p&gt;全局解释器锁（GIL）是一种互斥锁，由程序语言解析线程持有，用于避免代码共享可能导致的线程安全问题。在支持GIL的语言中，每一个解释器进程中都会含有一个GIL。&lt;/p&gt;

&lt;p&gt;每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.&lt;/p&gt;

&lt;p&gt;那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行, 多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.&lt;/p&gt;

&lt;h4 id=&#34;gil应用:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;GIL应用&lt;/h4&gt;

&lt;p&gt;一些支持 GIL 的语言的实现包括 CPython（Python 语言最被广泛使用的一种实现），Ruby MRI（Ruby 的推荐实现，GIL 在 Ruby 中被称为 Global VM Lock）&lt;/p&gt;

&lt;p&gt;基于 JVM 的上述语言的等价实现（Jython 和 JRuby）不使用 GIL。IronPython 和 IronRuby 被实现成微软的动态语言运行时，并在其中避免使用 GIL 。&lt;/p&gt;

&lt;h4 id=&#34;关于gil的争议:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;关于GIL的争议&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;认为应该去除 GIL 的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不顺应计算机的发展潮流(多核时代已经到来, 而 GIL 会很影响多核的使用)&lt;/li&gt;
&lt;li&gt;大幅度提升多线程程序的速度&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;认为不应该去除 GIL 的(如果去掉,会):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;写python的扩展(module)时会遇到锁的问题,程序员需要繁琐地加解锁来保证线程安全&lt;/li&gt;
&lt;li&gt;会较大幅度地减低单线程程序的速度&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;gil设计的缺陷:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;GIL设计的缺陷&lt;/h4&gt;

&lt;p&gt;基于pcode数量的调度方式&lt;/p&gt;

&lt;p&gt;按照Python社区的想法，操作系统本身的线程调度已经非常成熟稳定了，没有必要自己搞一套。所以Python的线程就是C语言的一个pthread，并通过操作系统调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度（当然是否真正进行上下文切换由操作系统自主决定）。&lt;/p&gt;

&lt;p&gt;伪代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while True:
    acquire GIL
    for i in 1000:
        do something
    release GIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）。但当CPU有多个核心的时候，问题就来了。从伪代码可以看到，从 release GIL 到 acquire GIL 之间几乎是没有间隙的。所以当其他在其他核心上的线程被唤醒时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。&lt;/p&gt;

&lt;p&gt;Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。&lt;/p&gt;

&lt;h4 id=&#34;解决办法:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;解决办法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;用multiprocess替代Thread&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。&lt;/p&gt;

&lt;p&gt;当然multiprocess也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocess由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。具体难点在哪有兴趣的读者可以扩展阅读 这篇文章&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用其他解析器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前也提到了既然GIL只是CPython的产物，那么其他解析器是不是更好呢？没错，像JPython和IronPython这样的解析器由于实现语言的特性，他们不需要GIL的帮助。然而由于用了Java/C#用于解析器实现，他们也失去了利用社区众多C语言模块有用特性的机会。所以这些解析器也因此一直都比较小众。毕竟功能和性能大家在初期都会选择前者， Done is better than perfect 。
所以没救了么？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;另一个改进 Reworking the GIL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将切换颗粒度从基于opcode计数改成基于时间片计数&lt;/li&gt;
&lt;li&gt;避免最近一次释放GIL锁的线程再次被立即调度&lt;/li&gt;
&lt;li&gt;新增线程优先级功能（高优先级线程可以迫使其他线程释放所持有的GIL锁）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;Python GIL其实是功能和性能之间权衡后的产物，它尤其存在的合理性，也有较难改变的客观因素。从本分的分析中，我们可以做以下一些简单的总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GIL在较长一段时间内将会继续存在，但是会不断对其进行改进&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;参考文章:46f6c6eb85e710b6752b8fcd11e3d818&#34;&gt;参考文章：&lt;/h5&gt;

&lt;p&gt;1.&lt;a href=&#34;http://www.tuicool.com/articles/7zIra2r&#34;&gt;http://www.tuicool.com/articles/7zIra2r&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;http://my.oschina.net/moooofly/blog/178531&#34;&gt;http://my.oschina.net/moooofly/blog/178531&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>http://cuick.github.io/python/101_bibao/</link>
      <pubDate>Sat, 19 Mar 2016 20:24:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/101_bibao/</guid>
      <description>&lt;p&gt;闭包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def make_addr(addend):
    def addr(augend):
        return augend + addend
    return addr

p = make_addr(23)
q = make_addr(42)

print p(10)
print q(10)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Django笔记(一)</title>
      <link>http://cuick.github.io/django/101/</link>
      <pubDate>Tue, 15 Mar 2016 22:06:53 +0800</pubDate>
      
      <guid>http://cuick.github.io/django/101/</guid>
      <description>

&lt;h2 id=&#34;安装:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;同其他python模块的安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pip install Django==1.9.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基本命令:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;基本命令&lt;/h2&gt;

&lt;h4 id=&#34;1-新建一个-django-projec:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;1.新建一个 django projec:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;django-admin.py startproject project-name

mysite
├── manage.py
└── mysite
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建了一个 mysite 目录，其中还有一个 mysite 目录&lt;br /&gt;
一些项目的设置 settings.py 文件，&lt;br /&gt;
总的urls配置文件 urls.py&lt;br /&gt;
部署服务器时用到的 wsgi.py 文件，&lt;br /&gt;
 &lt;strong&gt;init&lt;/strong&gt; .py 是python包的目录结构必须的，与调用有关。&lt;/p&gt;

&lt;h4 id=&#34;2-新建-app:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;2.新建 app:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;python manage.py startapp app-name
django-admin.py startapp app-name
app-name/
├── __init__.py
├── admin.py
├── models.py
├── tests.py
└── views.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把我们新定义的app加到settings.py中的INSTALL_APPS中&lt;br /&gt;
修改 mysite/mysite/settings.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,

    &#39;myapp&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用开发服务器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Twisted基础</title>
      <link>http://cuick.github.io/twisted/twisted_basic/</link>
      <pubDate>Sat, 27 Feb 2016 22:17:23 +0800</pubDate>
      
      <guid>http://cuick.github.io/twisted/twisted_basic/</guid>
      <description>

&lt;h2 id=&#34;twisted:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Twisted&lt;/h2&gt;

&lt;h3 id=&#34;twisted特点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;twisted特点：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在一个回调函数执行过程中，实际上Twisted的循环是被有效地阻塞在我们的代码上的。因此，因此我们应该确保回调函数不要浪费时间（尽快返回）。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;很多标准的Python方法没有办法转换为非阻塞方式。例如，os.system中的很多方法会在子进程完成前一直处于阻塞状态。这也就是它工作的方式。所以当你使用Twisted时，避开使用os.system。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们为Twisted程序写的API必须是异步的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不能将同步与异步代码混合起来使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们可以在自己的代码中写回调函数，正如Twisted做的那样&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;并且，我们需要写处理错误信息的回调函数&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;reactor:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Reactor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个真正reactor模式的实现是需要实现循环独立抽象出来并具有如下的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;监视一系列与你I/O操作相关的文件描述符（description)&lt;/li&gt;
&lt;li&gt;不停地向你汇报那些准备好I/O操作的文件描述符&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个设计优秀的reactor模式实现需要做到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;处理所有不同系统会出现的I/O事件&lt;/li&gt;
&lt;li&gt;提供优雅的抽象来帮助你在使用reactor时少花些心思去考虑它的存在&lt;/li&gt;
&lt;li&gt;提供你可以在抽象层外（treactor实现）使用的公共协议实现。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reactor特性&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用twisted.internet.pollreactor中的系统调用来poll 来代替select方法&lt;br /&gt;
from twited.internet import pollreactor&lt;br /&gt;
pollreactor.install()&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
reactor.run()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;transports:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Transports&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个Twisted的Transport代表一个可以收发字节的单条连接。对于我们的诗歌下载客户端而言，就是对一条TCP连接的抽象。&lt;/li&gt;
&lt;li&gt;ransport抽象可以代表任何这样的连接并为其代表的连接处理具体的异步I/O操作细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocols:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocols&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个具体的Twisted的Protocol的实现应该对应一个具体网络协议的实现，像FTP、IMAP或其它我们自己规定的协议。&lt;/li&gt;
&lt;li&gt;每一个Twisted的Protocols类实例都为一个具体的连接提供协议解析。&lt;/li&gt;
&lt;li&gt;Protocol实例是存储协议状态与间断性接收并累积数据的地方（由于我们是通过异步I/O方式以任意大小来接收数据的）。&lt;/li&gt;
&lt;li&gt;Protocol实例如何得知它为哪条连接服务呢？如果你阅读IProtocol定义会发现一个makeConnection函数。这是一个回调函数，Twisted会在调用它时传递给其一个也是仅有的一个参数，即就是Transport实例。这个Transport实例就代表Protocol将要使用的连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocol-factories:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocol Factories&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个连接需要一个自己的Portocol&lt;/li&gt;
&lt;li&gt;Protocol Factories一个新的连接制定一个合适的协议&lt;/li&gt;
&lt;li&gt;Protocol Factory就是Factory模式的一个具体实现。&lt;/li&gt;
&lt;li&gt;buildProtocol方法在每次被调用时返回一个新Protocol实例。它就是Twisted用来为新连接创建新Protocol实例的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;failure:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Failure&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果有异常出现的话，其能捕获Exception与跟踪栈。&lt;/li&gt;
&lt;li&gt;将一个Failure对象付给回调函数，我们就可以为以后的调试保存跟踪栈的信息了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关于回调:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;关于回调&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;激活errback是非常重要的。由于errback的功能与except块相同，因此用户需要确保它们的存在。他们并不可选项，而是必选项。&lt;/li&gt;
&lt;li&gt;不在错误的时间点激活回调与在正确的时间点激活回调同等重要。典型的用法是，callback与errback是互斥的即只能运行其中一个。&lt;/li&gt;
&lt;li&gt;使用回调函数的代码重构起来有些困难。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deferred-以让程序员在使用回调时更简便:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred-以让程序员在使用回调时更简便&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;

&lt;ol&gt;
&lt;li&gt;我们不能忽视errback，在任何异步编程的API中都需要它。Deferred支持errbacks。&lt;/li&gt;
&lt;li&gt;激活回调多次可能会导致很严重的问题。Deferred只能被激活一次，这就类似于同步编程中的try/except的处理方法。&lt;/li&gt;
&lt;li&gt;含有回调的程序在重构时相当困难。有了deferred，我们就通过修改回调链来重构程序。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;一个deferred有一个callback/errback对链，它们以添加到deferred中的顺序依次排列&lt;/li&gt;
&lt;li&gt;stage 0，即第一对errback/callbac，会在deferred激活时调用，具体调用那个看激活deferred的方式，若是通过.errback激活，则调用errback；同样若是通过.callback激活则调用callback。（这里的errback/callback实际是指通过addBoth添加的函数）&lt;/li&gt;
&lt;li&gt;如果stage N执行出现异常，则stage N+1的errback被调用，并且其参数即为stage N出现的异常&lt;/li&gt;
&lt;li&gt;同样，如果stage N成功，即没有抛出异常，则N+1的callback被调用，其第一个参数为stage N的返回值。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务器用ServerFactory而不是ClientFactory, 这是因为服务器是要被动地监听连接状态而不是像客户端一样去主动的创建。使用listenTCP方法.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deferred新特性:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred新特性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个deferred的回调链中的一个回函数可以再返回了一个 deferred&lt;/li&gt;
&lt;li&gt;当内层deferrd被激活时，外层的deferred恢复其回调链的执行。当内层deferred回调执行成功，那么外层deferred会调用第N+1个callback回调。相反，如果内层deferred执行失败，那么外层deferred会调用第N+1个errback回调
&lt;img src=&#34;http://cuick.github.io/twisted/deferred-111.png&#34; alt=&#34;deferred&#34; title=&#34;xxx&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看完下边这个例子就懂了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def callback_1(res):
    print &#39;callback_1 got&#39;, res
    return 1

def callback_2(res):
    print &#39;callback_2 got&#39;, res
    return 2

def callback_3(res):
    print &#39;callback_3 got&#39;, res
    return 3

def callback_2_async(res):
    print &#39;callback_2 got&#39;, res
    global deferred_2 # never do this in a real program
    deferred_2 = Deferred()
    return deferred_2

d = Deferred()

d.addCallback(callback_1)
d.addCallback(callback_2_async)
d.addCallback(callback_3)


d.callback(0)

deferred_2.callback(2)  # 调用这句之后内层的deferred才返回
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;deferred另一个新特性:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred另一个新特性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以在将Deferred返回前就激活这个Deferred。之所以可以这样做，是因为你可以在一个已经激活的deferred上添加回调处理函数。&lt;/li&gt;
&lt;li&gt;已经被激活的deferred可以立即激活新添加的回调处理函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def callback_1(res):
    print &#39;callback_1 got&#39;, res
    return 1

def callback_2(res):
    print &#39;callback_2 got&#39;, res
    return 2

def callback_3(res):
    print &#39;callback_3 got&#39;, res
    return 3

d = Deferred()

print &#39;Firing empty deferred.&#39;
d.callback(0)

# 下边添加的回调会立即返回
d.addCallback(callback_1)
d.addCallback(callback_2)
d.addCallback(callback_3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子二&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d = Deferred()
d.pause()  # 暂停deferred
d.callback(0)

d.addCallback(callback_1)
d.addCallback(callback_2)
d.addCallback(callback_3)

d.unpause()  # 取消暂停deferred， deferred开始返回
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>