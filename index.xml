<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K&#39;s blog!</title>
    <link>http://cuick.github.io/</link>
    <description>Recent content on K&#39;s blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Sep 2016 17:26:29 +0800</lastBuildDate>
    <atom:link href="http://cuick.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>git br -a 含有远端不存在分支</title>
      <link>http://cuick.github.io/git/git/</link>
      <pubDate>Fri, 02 Sep 2016 17:26:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/git/git/</guid>
      <description>&lt;p&gt;git fetch -p&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python基础-面向对象</title>
      <link>http://cuick.github.io/python/112_oop/</link>
      <pubDate>Fri, 15 Apr 2016 15:07:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/112_oop/</guid>
      <description>

&lt;h3 id=&#34;访问限制:0589866b25f4e1e0a9df23909371bb14&#34;&gt;访问限制&lt;/h3&gt;

&lt;p&gt;在Python中，变量名类似&lt;code&gt;__xxx__&lt;/code&gt;的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用&lt;code&gt;__name__&lt;/code&gt;、&lt;code&gt;__score__&lt;/code&gt;这样的变量名&lt;/p&gt;

&lt;p&gt;如果要让类内部属性不被外部访问，可以把属性的名称前加上两个下划线&lt;code&gt;__&lt;/code&gt;，在Python中，实例的变量名如果以&lt;code&gt;__&lt;/code&gt;开头，就变成了一个私有变量（private）&lt;/p&gt;

&lt;p&gt;双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问&lt;code&gt;__name&lt;/code&gt;是因为Python解释器对外把&lt;code&gt;__name&lt;/code&gt;变量改成了&lt;code&gt;_Student__name&lt;/code&gt;，所以，仍然可以通过&lt;code&gt;_Student__name&lt;/code&gt;来访问&lt;code&gt;__name&lt;/code&gt;变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Student(object):

def __init__(self, name, score):
    self.__name = name
    self.__score = score

def print_score(self):
    print &#39;%s: %s&#39; % (self.__name, self.__score)

&amp;gt;&amp;gt;&amp;gt; bart._Student__name
&#39;Bart Simpson&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是永远不要这么干&lt;/p&gt;

&lt;h3 id=&#34;获取对象信息:0589866b25f4e1e0a9df23909371bb14&#34;&gt;获取对象信息&lt;/h3&gt;

&lt;h4 id=&#34;type:0589866b25f4e1e0a9df23909371bb14&#34;&gt;type&lt;/h4&gt;

&lt;p&gt;判断对象类型&lt;/p&gt;

&lt;p&gt;所有类型本身的类型就是TypeType&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; type(int)==type(str)==types.TypeType
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;isinstance:0589866b25f4e1e0a9df23909371bb14&#34;&gt;isinstance&lt;/h4&gt;

&lt;p&gt;判断 一个对象是否是某种类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = Animal()
&amp;gt;&amp;gt;&amp;gt; d = Dog()
&amp;gt;&amp;gt;&amp;gt; h = Husky()

&amp;gt;&amp;gt;&amp;gt; isinstance(h, Husky)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子类对象是是父类的类型&lt;/p&gt;

&lt;p&gt;父类对象 不是 子类 的类型&lt;/p&gt;

&lt;p&gt;能用type()判断的基本类型也可以用isinstance()判断&lt;/p&gt;

&lt;p&gt;还可以判断一个变量是否是某些类型中的一种:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;a&#39;, (str, unicode))
True
&amp;gt;&amp;gt;&amp;gt; isinstance(u&#39;a&#39;, (str, unicode))
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dir:0589866b25f4e1e0a9df23909371bb14&#34;&gt;dir()&lt;/h4&gt;

&lt;p&gt;获得一个对象的所有属性和方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(&#39;ABC&#39;)
[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__getslice__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;_formatter_field_name_split&#39;, &#39;_formatter_parser&#39;, &#39;capitalize&#39;, &#39;center&#39;, &#39;count&#39;, &#39;decode&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdigit&#39;, &#39;islower&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&amp;gt;&amp;gt;&amp;gt; obj = MyObject()

&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; obj.x
9
&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
False
&amp;gt;&amp;gt;&amp;gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;
&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;
19
&amp;gt;&amp;gt;&amp;gt; obj.y # 获取属性&#39;y&#39;
19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果试图获取不存在的属性，会抛出AttributeError的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;z&#39;) # 获取属性&#39;z&#39;
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以传入一个default参数，如果属性不存在，就返回默认值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404
404
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以获得对象的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;
&amp;lt;bound method MyObject.power of &amp;lt;__main__.MyObject object at 0x108ca35d0&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fn = getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn
&amp;gt;&amp;gt;&amp;gt; fn # fn指向obj.power
&amp;lt;bound method MyObject.power of &amp;lt;__main__.MyObject object at 0x108ca35d0&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fn() # 调用fn()与调用obj.power()是一样的
81
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;动态添加属性:0589866b25f4e1e0a9df23909371bb14&#34;&gt;动态添加属性&lt;/h3&gt;

&lt;p&gt;定义class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Student(object):
...     pass
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绑定属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = Student()
&amp;gt;&amp;gt;&amp;gt; s.name = &#39;Michael&#39; # 动态给实例绑定一个属性
&amp;gt;&amp;gt;&amp;gt; print s.name
Michael
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给一个实例绑定方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&amp;gt;&amp;gt;&amp;gt; from types import MethodType
&amp;gt;&amp;gt;&amp;gt; s.set_age = MethodType(set_age, s, Student) # 给实例绑定一个方法
&amp;gt;&amp;gt;&amp;gt; s.set_age(25) # 调用实例方法
&amp;gt;&amp;gt;&amp;gt; s.age # 测试结果
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给class绑定方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def set_score(self, score):
...     self.score = score
...
&amp;gt;&amp;gt;&amp;gt; Student.set_score = MethodType(set_score, None, Student)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给实例绑定方法后其他的实例不能使用
给类绑定方法后所有的实例都可以使用&lt;/p&gt;

&lt;p&gt;动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现&lt;/p&gt;

&lt;h4 id=&#34;slots:0589866b25f4e1e0a9df23909371bb14&#34;&gt;&lt;code&gt;__slots__&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Python允许在定义class的时候，定义一个特殊的&lt;code&gt;__slots__&lt;/code&gt;变量，来限制该class能添加的属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Student(object):
...     __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称
...

&amp;gt;&amp;gt;&amp;gt; s = Student() # 创建新的实例
&amp;gt;&amp;gt;&amp;gt; s.name = &#39;Michael&#39; # 绑定属性&#39;name&#39;
&amp;gt;&amp;gt;&amp;gt; s.age = 25 # 绑定属性&#39;age&#39;
&amp;gt;&amp;gt;&amp;gt; s.score = 99 # 绑定属性&#39;score&#39;
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;__slots__&lt;/code&gt;定义的属性仅对当前类起作用，对继承的子类是不起作用的&lt;/p&gt;

&lt;p&gt;非在子类中也定义&lt;code&gt;__slots__&lt;/code&gt;，这样，子类实例允许定义的属性就是自身的&lt;code&gt;__slots__&lt;/code&gt;加上父类的&lt;code&gt;__slots__&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;property:0589866b25f4e1e0a9df23909371bb14&#34;&gt;@property&lt;/h4&gt;

&lt;p&gt;Python内置的@property装饰器负责把一个方法变成属性调用&lt;/p&gt;

&lt;h3 id=&#34;多重继承:0589866b25f4e1e0a9df23909371bb14&#34;&gt;多重继承&lt;/h3&gt;

&lt;p&gt;在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;定制类:0589866b25f4e1e0a9df23909371bb14&#34;&gt;定制类&lt;/h3&gt;

&lt;p&gt;类似&lt;code&gt;__slots__&lt;/code&gt;这种形如&lt;code&gt;__xxx__&lt;/code&gt;的变量或者函数名就要注意，这些在Python中是有特殊用途的
thon的class中还有许多这样有特殊用途的函数，可以帮助我们定制类&lt;/p&gt;

&lt;h4 id=&#34;str-repr:0589866b25f4e1e0a9df23909371bb14&#34;&gt;&lt;code&gt;__str__()&lt;/code&gt; &lt;code&gt;__repr__()&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...
&amp;gt;&amp;gt;&amp;gt; print(Student(&#39;Michael&#39;))
&amp;lt;__main__.Student object at 0x109afb190&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;__str__&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return &#39;Student object (name: %s)&#39; % self.name
...
&amp;gt;&amp;gt;&amp;gt; print(Student(&#39;Michael&#39;))
Student object (name: Michael)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接敲变量不用print，打印出来的实例还是和未使用&lt;code&gt;__str__&lt;/code&gt;一样
使用&lt;code&gt;__repr__&lt;/code&gt;后 ，直接返回 设置的内容&lt;/p&gt;

&lt;p&gt;两者的区别是&lt;code&gt;__str__&lt;/code&gt;()返回用户看到的字符串，而&lt;code&gt;__repr__()&lt;/code&gt;返回程序开发者看到的字符串，也就是说，&lt;code&gt;__repr__()&lt;/code&gt;是为调试服务的&lt;/p&gt;

&lt;h4 id=&#34;iter:0589866b25f4e1e0a9df23909371bb14&#34;&gt;&lt;code&gt;__iter__&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;将对象实例变为迭代对象&lt;/p&gt;

&lt;p&gt;Python的for循环就会不断调用该迭代对象的&lt;code&gt;__next__()&lt;/code&gt;方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &amp;gt; 100000: # 退出循环的条件
            raise StopIteration();
        return self.a # 返回下一个值

&amp;gt;&amp;gt;&amp;gt; for n in Fib():
...     print(n)
...
1
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;getitem:0589866b25f4e1e0a9df23909371bb14&#34;&gt;&lt;code&gt;__getitem__&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;让对象可以和list一样去取值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

&amp;gt;&amp;gt;&amp;gt; f = Fib()
&amp;gt;&amp;gt;&amp;gt; f[0]
1
&amp;gt;&amp;gt;&amp;gt; f[1]
1
&amp;gt;&amp;gt;&amp;gt; f[2]
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入一个判断，让我们的对象实现切片的用法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &amp;gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L

&amp;gt;&amp;gt;&amp;gt; f = Fib()
&amp;gt;&amp;gt;&amp;gt; f[0:5]
[1, 1, 2, 3, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外 还可以结合&lt;code&gt;__setitem__()&lt;/code&gt;方法、&lt;code&gt;__delitem__()&lt;/code&gt;方法 等 去实现 dict一样的用法。&lt;/p&gt;

&lt;p&gt;我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口&lt;/p&gt;

&lt;p&gt;鸭子类型：
一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。
“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”&lt;/p&gt;

&lt;h4 id=&#34;getattr:0589866b25f4e1e0a9df23909371bb14&#34;&gt;&lt;code&gt;__getattr__&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用不存在的属性时，比如score，Python解释器会试图调用&lt;code&gt;__getattr__&lt;/code&gt;(self, &amp;lsquo;score&amp;rsquo;)来尝试获得属性，这样，我们就有机会返回score的值
也可以返回函数&lt;/p&gt;

&lt;p&gt;只有在没有找到属性的情况下，才调用&lt;code&gt;__getattr__&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;属性如果在getattr里不存在，默认返回是None，而不是抛出异常,如果要实现，需要自己抛出&lt;/p&gt;

&lt;h4 id=&#34;call:0589866b25f4e1e0a9df23909371bb14&#34;&gt;&lt;code&gt;__call__&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;实现这个函数可以通过直接调用对象来调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&#39;My name is %s.&#39; % self.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;枚举类:0589866b25f4e1e0a9df23909371bb14&#34;&gt;枚举类&lt;/h3&gt;

&lt;p&gt;定义常量时，通常用大写变量整数来定义&lt;/p&gt;

&lt;p&gt;更好的方法是用枚举类型 Enum&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from enum import Enum
Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from enum import Enum, unique
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;. 还是学c/c++的时候在系统的学一下枚举吧。。&lt;/p&gt;

&lt;h3 id=&#34;元类:0589866b25f4e1e0a9df23909371bb14&#34;&gt;元类&lt;/h3&gt;

&lt;h4 id=&#34;type-1:0589866b25f4e1e0a9df23909371bb14&#34;&gt;type&lt;/h4&gt;

&lt;p&gt;type()函数既可以返回一个对象的类型，又可以创建出新的类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def fn(self, name=&#39;world&#39;): # 先定义函数
...     print(&#39;Hello, %s.&#39; % name)
...
&amp;gt;&amp;gt;&amp;gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class
&amp;gt;&amp;gt;&amp;gt; h = Hello()
&amp;gt;&amp;gt;&amp;gt; h.hello()
Hello, world.
&amp;gt;&amp;gt;&amp;gt; print(type(Hello))
&amp;lt;class &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(h))
&amp;lt;class &#39;__main__.Hello&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;class的名称；&lt;/li&gt;
&lt;li&gt;继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；&lt;/li&gt;
&lt;li&gt;class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同&lt;/p&gt;

&lt;h4 id=&#34;metaclass:0589866b25f4e1e0a9df23909371bb14&#34;&gt;metaclass&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.jobbole.com/21351/&#34;&gt;http://blog.jobbole.com/21351/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python基础-模块</title>
      <link>http://cuick.github.io/python/111_module/</link>
      <pubDate>Wed, 13 Apr 2016 15:07:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/111_module/</guid>
      <description>

&lt;h2 id=&#34;包:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;包&lt;/h2&gt;

&lt;p&gt;避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package1
├─ __init__.py
├── admin.py
├── models.py
├── tests.py
└─ views.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个包目录下面都会有一个&lt;code&gt;__init__.py&lt;/code&gt;的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。&lt;strong&gt;init&lt;/strong&gt;.py可以是空文件，也可以有Python代码，因为&lt;strong&gt;init&lt;/strong&gt;.py本身就是一个模块，而它的模块名就是mycompany&lt;/p&gt;

&lt;p&gt;可以有多级目录，组成多级层次的包结构。&lt;/p&gt;

&lt;h2 id=&#34;模块:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;模块&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在Python中，一个.py文件就称之为一个模块（Module）。

#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39; a test module &#39;

__author__ = &#39;Michael Liao&#39;

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print &#39;Hello, world!&#39;
    elif len(args)==2:
        print &#39;Hello, %s!&#39; % args[1]
    else:
        print &#39;Too many arguments!&#39;

if __name__==&#39;__main__&#39;:
    test()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量&lt;code&gt;__name__&lt;/code&gt;置为&lt;code&gt;__main__&lt;/code&gt;，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。&lt;/p&gt;

&lt;h2 id=&#34;使用模块:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;使用模块&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import sys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能&lt;/p&gt;

&lt;h3 id=&#34;别名:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;别名&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;try:
    import cStringIO as StringIO
except ImportError: # 导入失败会捕获到ImportError
    import StringIO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于Python是动态语言，函数签名一致接口就一样，因此，无论导入哪个模块后续代码都能正常工作&lt;/p&gt;

&lt;h2 id=&#34;第三方模块:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;第三方模块&lt;/h2&gt;

&lt;h3 id=&#34;安装:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Python有两个封装了setuptools的包管理工具：easy_install和pip。&lt;/p&gt;

&lt;h3 id=&#34;模块搜索路径:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;模块搜索路径&lt;/h3&gt;

&lt;p&gt;当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错&lt;/p&gt;

&lt;p&gt;Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中&lt;/p&gt;

&lt;h3 id=&#34;添加自己的搜索目录:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;添加自己的搜索目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法一：直接修改sys.path，添加要搜索的目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方法二：设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;future:2e443d841f9bf0a6e5f9c1a9e8bdae98&#34;&gt;future&lt;/h3&gt;

&lt;p&gt;Python提供了&lt;code&gt;__future__&lt;/code&gt;模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。&lt;/p&gt;

&lt;p&gt;果你想在Python 2.7的代码中直接使用Python 3.x的除法，可以通过&lt;code&gt;__future__&lt;/code&gt;模块的division实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from __future__ import division

print &#39;10 / 3 =&#39;, 10 / 3
print &#39;10.0 / 3 =&#39;, 10.0 / 3
print &#39;10 // 3 =&#39;, 10 // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 / 3 = 3.33333333333
10.0 / 3 = 3.33333333333
10 // 3 = 3
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python-函数式编程</title>
      <link>http://cuick.github.io/python/110_fp/</link>
      <pubDate>Tue, 12 Apr 2016 15:58:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/110_fp/</guid>
      <description>

&lt;h2 id=&#34;关于函数式编程:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;关于函数式编程&lt;/h2&gt;

&lt;p&gt;函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。&lt;/p&gt;

&lt;p&gt;而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算&lt;/p&gt;

&lt;p&gt;越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言&lt;/p&gt;

&lt;p&gt;函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。&lt;/p&gt;

&lt;p&gt;函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！&lt;/p&gt;

&lt;p&gt;Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。&lt;/p&gt;

&lt;h2 id=&#34;高阶函数-higher-order-function:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;高阶函数 Higher-order function&lt;/h2&gt;

&lt;h4 id=&#34;什么是:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;什么是&lt;/h4&gt;

&lt;p&gt;把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。&lt;/p&gt;

&lt;h4 id=&#34;map-reduce:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;map/reduce&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def f(x):
...     return x * x
...
&amp;gt;&amp;gt;&amp;gt; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def fn(x, y):
...     return x * 10 + y
...
&amp;gt;&amp;gt;&amp;gt; reduce(fn, [1, 3, 5, 7, 9])
13579

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;filter:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;filter&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; def a(b):
....     return b&amp;gt;5
....
&amp;gt;&amp;gt;&amp;gt;&amp;gt; b = [1,2,3,6,7,8]
&amp;gt;&amp;gt;&amp;gt;&amp;gt; filter(a,b)
[6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sorted:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;sorted&lt;/h4&gt;

&lt;p&gt;sorted()函数可以对list进行排序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;返回函数:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;返回函数&lt;/h2&gt;

&lt;p&gt;一个函数可以返回一个计算结果，也可以返回一个函数。&lt;/p&gt;

&lt;p&gt;返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。&lt;/p&gt;

&lt;h4 id=&#34;闭包:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def make_addr(addend):
    def addr(augend):
        return augend + addend
    return addr

p = make_addr(23)
q = make_addr(42)

print p(10)
print q(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种返回的函数带有外部函数的参数 的 函数，属于闭包函数&lt;/p&gt;

&lt;h2 id=&#34;匿名函数:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;匿名函数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lambda x: x * x&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关键字lambda表示匿名函数，冒号前面的x表示函数参数。&lt;/p&gt;

&lt;p&gt;匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。&lt;/p&gt;

&lt;p&gt;用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突&lt;/p&gt;

&lt;p&gt;匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数&lt;/p&gt;

&lt;h2 id=&#34;装饰器-decorator:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;装饰器 Decorator&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;decorator就是一个返回函数的高阶函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def log(func):
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&#39;2015-3-25&#39;)

&amp;gt;&amp;gt; now()
call now():
2015-3-25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的装饰器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者针对带参数的decorator：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在面向对象（OOP）的设计模式中，decorator被称为装饰模式&lt;/p&gt;

&lt;h2 id=&#34;偏函数-partial-function:5d974e52f6440f66e5eafa0028ddc75c&#34;&gt;偏函数 Partial function&lt;/h2&gt;

&lt;p&gt;functools模块的partial函数&lt;/p&gt;

&lt;p&gt;当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。&lt;/p&gt;

&lt;p&gt;普通使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;12345&#39;, base=8)
5349
&amp;gt;&amp;gt;&amp;gt; int(&#39;12345&#39;, 16)
74565
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用默认参数实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def int2(x, base=2):
    return int(x, base)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;偏函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import functools
&amp;gt;&amp;gt;&amp;gt; int2 = functools.partial(int, base=2)
&amp;gt;&amp;gt;&amp;gt; int2(&#39;1000000&#39;)
64
&amp;gt;&amp;gt;&amp;gt; int2(&#39;1010101&#39;)
85
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python-特性(切片、迭代...)</title>
      <link>http://cuick.github.io/python/109_special/</link>
      <pubDate>Mon, 11 Apr 2016 15:58:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/109_special/</guid>
      <description>

&lt;h2 id=&#34;切片:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;切片&lt;/h2&gt;

&lt;p&gt;取一个list或tuple的部分元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果第一个索引是0，还可以省略L[:3]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;倒数第一个元素的索引是-1。L[-2:-1]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;L[:]就可以原样复制一个list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串&amp;rsquo;xxx&amp;rsquo;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;L[:10:2],前10个数，每两个取一个&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;迭代:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;迭代&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样&lt;/li&gt;

&lt;li&gt;&lt;p&gt;判断一个对象是可迭代对象用collections模块的Iterable进行判断&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Iterable
&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代
True
&amp;gt;&amp;gt;&amp;gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&amp;gt;&amp;gt;&amp;gt; isinstance(123, Iterable) # 整数是否可迭代
False
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):
...     print(i, value)
...
0 A
1 B
2 C
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;列表生成式:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;列表生成式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;range(3)  [0,1,2]&lt;/li&gt;
&lt;li&gt;[x * x for x in range(1, 11)]  生成[1*1,2*2 &amp;hellip; 11*11]&lt;/li&gt;
&lt;li&gt;[x * x for x in range(1, 11) if x % 2 == 0] 偶数的平方的列表&lt;/li&gt;

&lt;li&gt;&lt;p&gt;两层循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在python3.x里range生成的是一个迭代对象而不是list，要想生成list需要list(range(n))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;生成器:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;生成器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列表元素可以按照某种算法推算出来，我们是否可以在循环的过程中不断推算出后续的元素,这样就不必创建完整的list，从而节省大量的空间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这种一边循环一边计算的机制，称为 &lt;em&gt;生成器&lt;/em&gt; （Generator）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建生成器：把一个列表生成式的[]改成()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = [x * x for x in range(10)]
&amp;gt;&amp;gt;&amp;gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&amp;gt;&amp;gt;&amp;gt; g = (x * x for x in range(10))
&amp;gt;&amp;gt;&amp;gt; g
&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x104feab40&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获得每个元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g.next()
0
&amp;gt;&amp;gt;&amp;gt; g.next()
1
...
&amp;gt;&amp;gt;&amp;gt; g.next()
64
&amp;gt;&amp;gt;&amp;gt; g.next()
81
&amp;gt;&amp;gt;&amp;gt; g.next()
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
  StopIteration
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为generator也是可迭代对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g = (x * x for x in range(10))
&amp;gt;&amp;gt;&amp;gt; for n in g:
...     print n
...
0
1
4
9
16
25
36
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建了一个generator后，很少调用next()方法，而是通过for循环来迭代它&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def fib(max):
    n, a, b = 0, 0, 1
    while n &amp;lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;迭代器:79290c2d83e6fde04d9f892eafcbd74d&#34;&gt;迭代器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;可作用于for循环的对象都是可迭代对象Iterable类型；&lt;/li&gt;
&lt;li&gt;可作用于next()函数的对象都是迭代器Iterator类型，它们表示一个惰性计算的序列；&lt;/li&gt;
&lt;li&gt;集合数据类型如list、dict、str等是可迭代对象Iterable但不是迭代器Iterator，不过可以通过iter()函数获得一个迭代器Iterator对象。&lt;/li&gt;
&lt;li&gt;生成器generator都是迭代器Iterator&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>python基础-函数</title>
      <link>http://cuick.github.io/python/108_fun/</link>
      <pubDate>Sun, 10 Apr 2016 15:07:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/108_fun/</guid>
      <description>

&lt;h2 id=&#34;所有内置函数:de303522e70934a82875d78047200a03&#34;&gt;所有内置函数&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html&#34;&gt;https://docs.python.org/3/library/functions.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;return:de303522e70934a82875d78047200a03&#34;&gt;return&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;函数可以返回多个值。&lt;/li&gt;
&lt;li&gt;但其实这只是一种假象，Python函数返回的仍然是单一值,一个tuple&lt;/li&gt;
&lt;li&gt;* 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参数:de303522e70934a82875d78047200a03&#34;&gt;参数&lt;/h2&gt;

&lt;h4 id=&#34;位置参数:de303522e70934a82875d78047200a03&#34;&gt;位置参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def a(x, y):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;默认参数:de303522e70934a82875d78047200a03&#34;&gt;默认参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def a(x=1):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;一定要注意默认参数的默认值不要设置为可变对象（比如 list dict 等）&lt;/li&gt;
&lt;li&gt;可以用None等代替&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;可变参数:de303522e70934a82875d78047200a03&#34;&gt;可变参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; calc(*nums)
14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*nums表示把nums这个list的所有元素作为可变参数传进去。&lt;/p&gt;

&lt;h4 id=&#34;关键字参数:de303522e70934a82875d78047200a03&#34;&gt;关键字参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def person(name, age, **kw):
    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, **extra)
name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以先组装出一个dict，在传入的参数前面加**，把该dict转换为关键字参数传进去&lt;/p&gt;

&lt;h4 id=&#34;命名关键字参数-只有python3-x版本有:de303522e70934a82875d78047200a03&#34;&gt;命名关键字参数(只有python3.x版本有)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def person(name, age, *, city, job):
    print(name, age, city, job)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命名关键字参数时，要特别注意，*不是参数，而是特殊分隔符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)
Jack 24 Beijing Engineer
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参数组合:de303522e70934a82875d78047200a03&#34;&gt;参数组合&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;def f1(a, b=1, *, c, **kw):
    print(a,b,c,kw)

def f2(a, b=0, *args, **kw):
    print(a,b,args,kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;除了可变参数无法和命名关键字参数混合,其他均可组合使用&lt;/li&gt;
&lt;li&gt;参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;总结:de303522e70934a82875d78047200a03&#34;&gt;总结&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可变参数，函数内转为tuple，&lt;/li&gt;
&lt;li&gt;关键字参数，函数内转为dict&lt;/li&gt;
&lt;li&gt;调用时，可在变量前加*，把list或者tuple作为可变参数传入函数内&lt;/li&gt;
&lt;li&gt;调用时，可在变量前加**，把dict作为关键字参数传入函数内&lt;/li&gt;
&lt;li&gt;命名关键字参数在 &amp;gt;3.5 的版本中才有&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>python-赋值、引用、拷贝、作用域</title>
      <link>http://cuick.github.io/python/107_copy/</link>
      <pubDate>Thu, 07 Apr 2016 14:55:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/107_copy/</guid>
      <description>

&lt;h2 id=&#34;赋值-引用-浅复制-深复制:8d37479f728103ff01e750a3599e3a2e&#34;&gt;赋值 引用 浅复制 深复制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;python 中赋值语句总是建立对象的引用值，而不是复制对象。因此，python 变量更像是指针，而不是数据存储区域&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; values = [0, 1, 2]
&amp;gt;&amp;gt;&amp;gt; values[1] = values
&amp;gt;&amp;gt;&amp;gt; values
[0, [...], 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并非我预想de:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0, [0, 1, 2], 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要达到你所需要的效果，即得到 [0, [0, 1, 2], 2] 这个对象，你不能直接将 values[1] 指向 values 引用的对象本身，需要：&lt;/p&gt;

&lt;p&gt;所以你需要执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;values[1] = values[:]  #生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;values[:] 复制操作是所谓的「浅复制」(shallow copy)，当列表对象有嵌套的时候也会产生出乎意料的错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = [0, [1, 2], 3]
b = a[:]
a[0] = 8
a[1][1] = 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确答案是 a 为 [8, [1, 9], 3]，b 为 [0, [1, 9], 3]
b的第二个元组也变化了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;正确的复制嵌套元素的方法是进行「深复制」(deep copy)，方法是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy

 a = [0, [1, 2], 3]
 b = copy.deepcopy(a)
 a[0] = 8
 a[1][1] = 9
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;引用-and-复制:8d37479f728103ff01e750a3599e3a2e&#34;&gt;引用 and 复制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;没有限制条件的分片表达式（L[:]）能够复制序列，但此法只能浅层复制。&lt;/li&gt;
&lt;li&gt;字典 copy 方法，D.copy() 能够复制字典，但此法只能浅层复制&lt;/li&gt;
&lt;li&gt;有些内置函数，例如 list，能够生成拷贝 list(L),浅复制&lt;/li&gt;
&lt;li&gt;copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy&lt;/li&gt;
&lt;li&gt;对于不可变对象和可变对象来说，浅复制都是复制的引用，只是因为复制不变对象和复制不变对象的引用是等效的（因为对象不可变，当改变时会新建对象重新赋值）。所以看起来浅复制只复制不可变对象（整数，实数，字符串等），对于可变对象，浅复制其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了另一个标签而已。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-b-与-a-a-b:8d37479f728103ff01e750a3599e3a2e&#34;&gt;a+=b 与 a=a+b&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;L = [1, 2]
M = L
L = L + [3, 4]
print L, M
print &amp;quot;-------------------&amp;quot;
L = [1, 2]
M = L
L += [3, 4]
print L, M

[1, 2, 3, 4] [1, 2]
-------------------
[1, 2, 3, 4] [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;例子中两种操作结果不同&lt;/li&gt;
&lt;li&gt;x = x + y 定义一个x，合并x与y，赋值给x&lt;/li&gt;
&lt;li&gt;x += y 不生成新对象，只是把y添加到x内存块末尾，性能相比来要好&lt;/li&gt;
&lt;li&gt;x y 都为list时， +自动调用extend进行合并运算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python-从-2-x-到-3-x-语句变函数引发的变量作用域问题:8d37479f728103ff01e750a3599e3a2e&#34;&gt;python 从 2.x 到 3.x，语句变函数引发的变量作用域问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;def test():
    a = False
    exec (&amp;quot;a = True&amp;quot;)
    print (&amp;quot;a = &amp;quot;, a)
test()

b = False
exec (&amp;quot;b = True&amp;quot;)
print (&amp;quot;b = &amp;quot;, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同版本下结果分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.x：
a =  True
b =  True

3.x：
a =  False
b =  True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因：
在3.x版本中exec 由语句变成函数了，而在函数中变量默认都是局部的，也就是说
你所见到的两个 a，是两个不同的变量，分别处于不同的命名空间中，而不会冲突。&lt;/p&gt;

&lt;p&gt;兼容方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test():
    a = False
    ldict = locals()
    exec(&amp;quot;a=True&amp;quot;,globals(),ldict)
    a = ldict[&#39;a&#39;]
    print(a)

test()

b = False
exec(&amp;quot;b = True&amp;quot;, globals())
print(&amp;quot;b = &amp;quot;, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-变量作用域及其陷阱:8d37479f728103ff01e750a3599e3a2e&#34;&gt;python 变量作用域及其陷阱&lt;/h2&gt;

&lt;h3 id=&#34;可变与不可变对象:8d37479f728103ff01e750a3599e3a2e&#34;&gt;可变与不可变对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不可变对象包括int，float，long，str，tuple等&lt;/li&gt;
&lt;li&gt;可变对象包括list，set，dict等&lt;/li&gt;
&lt;li&gt;不可变指的是值的不可变。对于不可变类型的变量，如果要更改变量，则会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收&lt;/li&gt;
&lt;li&gt;不可变的类型可以计算hash值，可以作为字典的key&lt;/li&gt;
&lt;li&gt;可变类型数据对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变，但区域会变长或者变短。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;函数值传递:8d37479f728103ff01e750a3599e3a2e&#34;&gt;函数值传递&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;def func_int(a):
    a += 4

def func_list(a_list):
    a_list[0] = 4

t = 0
func_int(t)
print t
# output: 0

t_list = [1, 2, 3]
func_list(t_list)
print t_list
# output: [4, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;引起上面现象的原因:对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。&lt;/li&gt;
&lt;li&gt;在函数参数传递的时候，Python其实就是把参数里传入的变量对应的对象的引用依次赋值给对应的函数内部变量&lt;/li&gt;
&lt;li&gt;例子中func_int中的局部变量&amp;rdquo;a&amp;rdquo;其实是全部变量&amp;rdquo;t&amp;rdquo;所指向对象的另一个引用，由于整数对象是不可变的，所以当func_int对变量&amp;rdquo;a&amp;rdquo;进行修改的时候，实际上是将局部变量&amp;rdquo;a&amp;rdquo;指向到了整数对象&amp;rdquo;1&amp;rdquo;。所以很明显，func_list修改的是一个可变的对象，局部变量&amp;rdquo;a&amp;rdquo;和全局变量&amp;rdquo;t_list&amp;rdquo;指向的还是同一个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;局部变量-全局变量:8d37479f728103ff01e750a3599e3a2e&#34;&gt;局部变量 全局变量&lt;/h3&gt;

&lt;p&gt;例一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = &#39;foo&#39;
d = {&#39;a&#39;:1}
def f():
    s = &#39;bar&#39;
    d[&#39;b&#39;] = 2
f()
print s  # foo
print d  # {&#39;a&#39;: 1, &#39;b&#39;: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在s = &amp;lsquo;bar&amp;rsquo;这句中，它是“有歧义的“，因为它既可以是表示引用全局变量s，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global&lt;/li&gt;
&lt;li&gt;在d[&amp;lsquo;b&amp;rsquo;]=2这句中，它是“明确的”，因为如果把d当作是局部变量的话，它会报KeyError，所以它只能是引用全局的d,故不需要多此一举显式声明global&lt;/li&gt;
&lt;li&gt;止dict不需要global，所有”明确的“东西都不需要global&lt;/li&gt;
&lt;li&gt;int类型str类型之类的不可变对象，每一次操作就重建新的对象，他们只有一种修改方法，即x = y， 恰好这种修改方法同时也是创建变量的方法，所以产生了歧义，不知道是要修改还是创建。而dict/list/对象等可变对象，操作不会重建对象，可以通过dict[&amp;lsquo;x&amp;rsquo;]=y或list.append()之类的来修改，跟创建变量不冲突，不产生歧义，所以都不用显式global。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例二&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list_a = []
def a():
    list_a = [1]      ## 语句1
a()
print list_a    # []
print &amp;quot;======================&amp;quot;
list_b = []
def b():
    list_b.append(1)    ## 语句2
b()
print list_b    # [1]
print &#39;=======================&#39;
list_c = [1]
def c():
    list_c[0] = 3      ## 语句3
c()
print list_c    # [3]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;语句1有歧义所以python规定是定义了一个局部变量。&lt;/li&gt;
&lt;li&gt;语句2与语句3没有歧义，是修改了全局变量，不然会是报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;永远不要用可变的默认参数:8d37479f728103ff01e750a3599e3a2e&#34;&gt;永远不要用可变的默认参数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;def foo(a, b, c=[]):
# append to c
# do some more stuff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法，每次调用foo，用的都是同一个引用，同一个地方修改了c的值，其他地方跟着变。非常可怕！！！！！！！&lt;/p&gt;

&lt;p&gt;要修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def foo(a, b, c=None):
    if c is None:
        c = []
    # append to c
    # do some more stuff
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python基础-list tuple set</title>
      <link>http://cuick.github.io/python/106_list_tuple_set/</link>
      <pubDate>Thu, 07 Apr 2016 14:55:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/106_list_tuple_set/</guid>
      <description>

&lt;h2 id=&#34;tuple-元组:9fbbb2834f2223c20142fe491c70f5c4&#34;&gt;tuple 元组&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;要定义一个只有1个元素的tuple，如果你这么定义&lt;code&gt;a = (1)&lt;/code&gt;,
定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。
只有1个元素的tuple定义时必须加一个逗号,，来消除歧义,&lt;code&gt;a=(1,)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tuple所谓的“不变”是说，tuple的每个元素，指向永远不变&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;list-列表:9fbbb2834f2223c20142fe491c70f5c4&#34;&gt;list 列表&lt;/h2&gt;

&lt;h2 id=&#34;set-集合:9fbbb2834f2223c20142fe491c70f5c4&#34;&gt;set 集合&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s2 = set([2, 3, 4])
&amp;gt;&amp;gt;&amp;gt; s1 &amp;amp; s2
set([2, 3])
&amp;gt;&amp;gt;&amp;gt; s1 | s2
set([1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>python基础-字符串和编码</title>
      <link>http://cuick.github.io/python/105_string/</link>
      <pubDate>Thu, 07 Apr 2016 09:55:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/105_string/</guid>
      <description>

&lt;h2 id=&#34;字符串:a23880f8b35e46659c516e699a542eed&#34;&gt;字符串&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;字符串是以单引号&lt;code&gt;&#39;&lt;/code&gt;或双引号&lt;code&gt;&amp;quot;&lt;/code&gt;括起来的任意文本，比如&lt;code&gt;&#39;abc&#39;&lt;/code&gt;，&lt;code&gt;&amp;quot;xyz&amp;quot;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果字符串内部既包含&lt;code&gt;&#39;&lt;/code&gt;又包含&lt;code&gt;&amp;quot;&lt;/code&gt;怎么办？可以用转义字符\来标识&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;I\&#39;m \&amp;quot;OK\&amp;quot;!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I&#39;m &amp;quot;OK&amp;quot;!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转义字符\可以转义很多字符，比如&lt;code&gt;\n&lt;/code&gt;表示换行，&lt;code&gt;\t&lt;/code&gt;表示制表符，字符\本身也要转义，所以&lt;code&gt;\\&lt;/code&gt;表示的字符就是\，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(&#39;\\\t\\&#39;)
\       \
&amp;gt;&amp;gt;&amp;gt; print(r&#39;\\\t\\&#39;)
\\\t\\
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&lt;code&gt;&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;的格式表示多行内容&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多行字符串&lt;code&gt;&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;还可以在前面加上r使用&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;编码:a23880f8b35e46659c516e699a542eed&#34;&gt;编码&lt;/h2&gt;

&lt;h4 id=&#34;ascii-unicode和utf-8的关系:a23880f8b35e46659c516e699a542eed&#34;&gt;ASCII、Unicode和UTF-8的关系&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。&lt;/li&gt;
&lt;li&gt;处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去,日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里,
各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。&lt;/li&gt;
&lt;li&gt;Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。
字母A用ASCII编码是十进制的65，二进制的01000001；&lt;/p&gt;

&lt;p&gt;字符0用ASCII编码是十进制的48，二进制的00110000，注意字符&amp;rsquo;0&amp;rsquo;和整数0是不同的；&lt;/p&gt;

&lt;p&gt;汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unicode编码转化为“可变长编码”的UTF-8编码。
UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。
如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;计算机系统通用的字符编码工作方式:a23880f8b35e46659c516e699a542eed&#34;&gt;计算机系统通用的字符编码工作方式&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;/li&gt;
&lt;li&gt;用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件&lt;/li&gt;
&lt;li&gt;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;python字符串-python2-7:a23880f8b35e46659c516e699a542eed&#34;&gt;python字符串(python2.7)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Python只支持ASCII编码&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u&amp;rsquo;&amp;hellip;&amp;lsquo;表示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print u&#39;中文&#39;
中文
&amp;gt;&amp;gt;&amp;gt; u&#39;中&#39;
u&#39;\u4e2d
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串&amp;rsquo;xxx&amp;rsquo;虽然是ASCII编码，但也可以看成是UTF-8编码，而u&amp;rsquo;xxx&amp;rsquo;则只能是Unicode编码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把u&amp;rsquo;xxx&amp;rsquo;转换为UTF-8编码的&amp;rsquo;xxx&amp;rsquo;用encode(&amp;lsquo;utf-8&amp;rsquo;)方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u&#39;ABC&#39;.encode(&#39;utf-8&#39;)
&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; u&#39;中文&#39;.encode(&#39;utf-8&#39;)
&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由unicode转化为指定的编码用encode。由指定编码 解码为 unicode 用decode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;英文字符转换后表示的UTF-8的值和Unicode值相等（但占用的存储空间不同），而中文字符转换后1个Unicode字符将变为3个UTF-8字符，\xe4就是其中一个字节，因为它的值是228，没有对应的字母可以显示，所以以十六进制显示字节的数值。len()函数可以返回字符串的长度&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；&lt;/p&gt;

&lt;p&gt;第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python3字符串是以Unicode编码的&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;格式化:a23880f8b35e46659c516e699a542eed&#34;&gt;格式化&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;采用的格式化方式和C语言是一致的，用%实现&lt;/li&gt;
&lt;li&gt;有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常见的占位符有：&lt;/p&gt;

&lt;p&gt;%d  整数
%f  浮点数
%s  字符串
%x  十六进制整数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;格式化整数和浮点数还可以指定是否补0和整数与小数的位数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &#39;%2d-%02d&#39; % (3, 1)
&#39; 3-01&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;%.2f&#39; % 3.1415926
&#39;3.14&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于Unicode字符串，用法完全一样，但最好确保替换的字符串也是Unicode字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u&#39;Hi, %s&#39; % u&#39;Michael&#39;
u&#39;Hi, Michael&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串里面的%是一个普通字符的时候就需要转义，用%%来表示一个%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &#39;growth rate: %d %%&#39; % 7
&#39;growth rate: 7 %&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python当然也支持其他编码方式，比如把Unicode编码成GB2312&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u&#39;中文&#39;.encode(&#39;gb2312&#39;)
&#39;\xd6\xd0\xce\xc4&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有特殊业务要求，请牢记仅使用Unicode和UTF-8这两种编码方式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Python 3.x版本中，把&amp;rsquo;xxx&amp;rsquo;和u&amp;rsquo;xxx&amp;rsquo;统一成Unicode编码，即写不写前缀u都是一样的&lt;/p&gt;

&lt;p&gt;由于Python3.x的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。&lt;/p&gt;

&lt;p&gt;Python3.x对bytes类型的数据用带b前缀的单引号或双引号表示：b&amp;rsquo;xxx&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>my vimrc</title>
      <link>http://cuick.github.io/vim/102/</link>
      <pubDate>Wed, 06 Apr 2016 23:03:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/vim/102/</guid>
      <description>&lt;p&gt;我的vim配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if !exists(&amp;quot;:DiffOrig&amp;quot;)
    command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
endif

syntax on

set t_Co=256
set mouse=a


set expandtab
set sw=4
set tabstop=4
set softtabstop=4

set nocompatible
set rtp+=~/.vim/bundle/Vundle.vim

set helplang=cn
set nu
set cindent
set smartindent
set showmatch
set ignorecase smartcase
set nowrapscan
set incsearch
set hlsearch
set magic
set sm
set backspace=indent,eol,start
set cmdheight=1

set laststatus=2
set autoread
set list lcs=tab:&amp;gt;-,trail:-

set fileencodings=utf-8,gb2312,gbk,gb18030
set termencoding=utf-8
set fileformats=unix
set encoding=utf-8

call vundle#begin()
Plugin &#39;gmarik/Vundle.vim&#39;
Plugin &#39;kien/ctrlp.vim&#39;
Plugin &#39;scrooloose/nerdtree&#39;
Plugin &#39;airblade/vim-gitgutter&#39;
Plugin &#39;Lokaltog/vim-easymotion&#39;
Plugin &#39;altercation/vim-colors-solarized&#39;
Plugin &#39;Valloric/YouCompleteMe&#39;
Plugin &#39;Shougo/vimshell.vim&#39;
Plugin &#39;scrooloose/syntastic&#39;
Plugin &#39;Shougo/vimproc.vim&#39;
Plugin &#39;vim-scripts/indentLine.vim&#39;
Plugin &#39;terryma/vim-multiple-cursors&#39;
Plugin &#39;tpope/vim-fugitive&#39;
Plugin &#39;tpope/vim-git&#39;
Plugin &#39;mileszs/ack.vim&#39;
Plugin &#39;mattn/emmet-vim&#39;
Plugin &#39;tpope/vim-surround&#39;
Plugin &#39;sjl/badwolf&#39;
Plugin &#39;gregsexton/gitv&#39;
Plugin &#39;plasticboy/vim-markdown&#39;
Plugin &#39;cespare/vim-toml&#39;
call vundle#end()
filetype plugin indent on

call pathogen#infect()
call pathogen#helptags()

let mapleader=&amp;quot; &amp;quot;
nnoremap &amp;lt;leader&amp;gt;jd :YcmCompleter GoTo&amp;lt;CR&amp;gt;

execute pathogen#infect()
let g:syntastic_python_checkers=[&#39;flake8&#39;]
let g:ycm_show_diagnostics_ui = 0
let g:syntastic_error_symbol = &amp;quot;✗&amp;quot;
let g:syntastic_style_error_symbol = &amp;quot;✗=&amp;quot;
let g:syntastic_warning_symbol = &amp;quot;⚠&amp;quot;
let g:syntastic_style_error_symbol = &amp;quot;⚠=&amp;quot;
let g:syntastic_auto_jump = 0

colorscheme badwolf

map &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;ss :source ~/.vimrc&amp;lt;cr&amp;gt;
map &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;ee :e ~/.vimrc&amp;lt;cr&amp;gt;

map  / &amp;lt;Plug&amp;gt;(easymotion-sn)
omap / &amp;lt;Plug&amp;gt;(easymotion-tn)
nmap s &amp;lt;Plug&amp;gt;(easymotion-s)

map &amp;lt;Leader&amp;gt;l &amp;lt;Plug&amp;gt;(easymotion-lineforward)
map &amp;lt;Leader&amp;gt;j &amp;lt;Plug&amp;gt;(easymotion-j)
map &amp;lt;Leader&amp;gt;k &amp;lt;Plug&amp;gt;(easymotion-k)
map &amp;lt;Leader&amp;gt;h &amp;lt;Plug&amp;gt;(easymotion-linebackward)
map &amp;lt;Leader&amp;gt;s :vimgrep &amp;lt;c-r&amp;gt;&amp;lt;c-w&amp;gt; **/*.py  &amp;lt;cr&amp;gt;
let g:EasyMotion_use_upper = 1
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_smartsign_us = 1
let g:ycm_global_ycm_extra_conf = &#39;~/.ycm_extra_conf.py&#39;
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_autoclose_preview_window_after_insertion = 1

nmap &amp;lt;c-p&amp;gt;&amp;lt;c-p&amp;gt; :CtrlPQuickfix&amp;lt;cr&amp;gt;
nmap &amp;lt;c-o&amp;gt;&amp;lt;c-p&amp;gt; :CtrlPMRU&amp;lt;cr&amp;gt;

map &amp;lt;leader&amp;gt;i :NERDTreeToggle &amp;lt;cr&amp;gt;
let NERDTreeIgnore=[&#39;.pyc$&#39;, &#39;\~$&#39;]
let g:NERDTreeQuitOnOpen = 1
let g:vim_markdown_folding_disabled = 1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>my zshrc</title>
      <link>http://cuick.github.io/zsh/101/</link>
      <pubDate>Wed, 06 Apr 2016 23:03:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/zsh/101/</guid>
      <description>&lt;p&gt;我的zsh配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export ZSH=$HOME/.oh-my-zsh
export PATH=&amp;quot;/usr/local/bin/pypy-5.0.1-linux_x86_64-portable/bin&amp;quot;:$PATH
ZSH_THEME=&amp;quot;af-magic&amp;quot;
export PATH=$HOME/bin:/usr/local/mysql/bin:$PATH
source $ZSH/oh-my-zsh.sh


setopt extended_glob
 TOKENS_FOLLOWED_BY_COMMANDS=(&#39;|&#39; &#39;||&#39; &#39;;&#39; &#39;&amp;amp;&#39; &#39;&amp;amp;&amp;amp;&#39; &#39;sudo&#39; &#39;do&#39; &#39;time&#39; &#39;strace&#39;)

 recolor-cmd() {
     region_highlight=()
     colorize=true
     start_pos=0
     for arg in ${(z)BUFFER}; do
         ((start_pos+=${#BUFFER[$start_pos+1,-1]}-${#${BUFFER[$start_pos+1,-1]## #}}))
         ((end_pos=$start_pos+${#arg}))
         if $colorize; then
             colorize=false
             res=$(LC_ALL=C builtin type $arg 2&amp;gt;/dev/null)
             case $res in
                 *&#39;reserved word&#39;*)   style=&amp;quot;fg=magenta,bold&amp;quot;;;
                 *&#39;alias for&#39;*)       style=&amp;quot;fg=cyan,bold&amp;quot;;;
                 *&#39;shell builtin&#39;*)   style=&amp;quot;fg=yellow,bold&amp;quot;;;
                 *&#39;shell function&#39;*)  style=&#39;fg=green,bold&#39;;;
                 *&amp;quot;$arg is&amp;quot;*)
                     [[ $arg = &#39;sudo&#39; ]] &amp;amp;&amp;amp; style=&amp;quot;fg=red,bold&amp;quot; || style=&amp;quot;fg=blue,bold&amp;quot;;;
                 *)                   style=&#39;none,bold&#39;;;
             esac
             region_highlight+=(&amp;quot;$start_pos $end_pos $style&amp;quot;)
         fi
         [[ ${${TOKENS_FOLLOWED_BY_COMMANDS[(r)${arg//|/\|}]}:+yes} = &#39;yes&#39; ]] &amp;amp;&amp;amp; colorize=true
         start_pos=$end_pos
     done
 }
check-cmd-self-insert() { zle .self-insert &amp;amp;&amp;amp; recolor-cmd }
 check-cmd-backward-delete-char() { zle .backward-delete-char &amp;amp;&amp;amp; recolor-cmd }

 zle -N self-insert check-cmd-self-insert
 zle -N backward-delete-char check-cmd-backward-delete-char

function rtn
{
    cd ~/work/transfer/TTransfer/frameworks/runtime-src/proj.ios_mac
    xcodebuild -project &amp;quot;TTransfer.xcodeproj&amp;quot; -configuration Debug -target &amp;quot;TTransfer Mac&amp;quot;
    open ~/work/transfer/TTransfer/runtime/mac/TTransfer Mac.app/Contents/MacOS/TTransfer\ Mac
    cd -
}

alias gp=&#39;git pull origin master:master&#39;
alias gm=&#39;git merge origin master&#39;
hash -d tv=~/work/traversing
export LC_ALL=en_US.utf-8
export LANG=&amp;quot;$LC_ALL&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>time计算日周月时间戳</title>
      <link>http://cuick.github.io/python/104_time/</link>
      <pubDate>Wed, 06 Apr 2016 20:48:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/104_time/</guid>
      <description>&lt;p&gt;计算自然周第一天、自然月第一天和每天的凌晨时间戳&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time

def get_day_begin(ts = time.time(),N = 0):
&amp;quot;&amp;quot;&amp;quot;
N为0时获取时间戳ts当天的起始时间戳，N为负数时前数N天，N为正数是后数N天
&amp;quot;&amp;quot;&amp;quot;

 return int(time.mktime(time.strptime(time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(ts)),&#39;%Y-%m-%d&#39;))) + 86400*N

def get_week_begin(ts = time.time(),N = 0):
&amp;quot;&amp;quot;&amp;quot;
N为0时获取时间戳ts当周的开始时间戳，N为负数时前数N周，N为整数是后数N周，此函数将周一作为周的第一天
&amp;quot;&amp;quot;&amp;quot;
 w = int(time.strftime(&#39;%w&#39;,time.localtime(ts)))
 return get_day_begin(int(ts - (w-1)*86400)) + N*604800

def get_month_begin(ts = time.time(),N = 0):
&amp;quot;&amp;quot;&amp;quot;
N为0时获取时间戳ts当月的开始时间戳，N为负数前数N月，N为正数后数N月
&amp;quot;&amp;quot;&amp;quot;
 month_day = {1:31,3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}
 cur_y,cur_m,cur_d = [int(x) for x in time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(ts)).split(&#39;-&#39;)]
 if (cur_y%4 == 0 and cur_y%100 != 0) or cur_y%400 == 0:
 month_day[2] = 29
else:
 month_day[2] = 28
 t = get_day_begin(ts) - (cur_d-1)*86400
 real_month = N + cur_m
 if real_month == cur_m:
 return t
 if N &amp;gt; 0:
 if real_month &amp;lt;= 12:
 for x in xrange(cur_m,real_month):
 t += month_day[x]*86400
 if real_month &amp;gt; 12:
 for x in xrange(cur_m,13):
 t += month_day[x]*86400
 t = get_month_begin(t,real_month - 13)
 if N &amp;lt; 0:
 if real_month &amp;gt;= 1:
 for x in xrange(real_month,cur_m):
 t -= month_day[x]*86400
 if real_month &amp;lt; 1:
 for x in xrange(1,cur_m):
 t -= month_day[x]*86400
 t -= month_day[12]*86400
 t = get_month_begin(t,real_month)
 return t

if __name__ ==&amp;quot;__main__&amp;quot;:
 t = time.time()
 print time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(get_day_begin(t,1)))
 print time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(get_week_begin(t,-2)))
 print time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(get_month_begin(t,-3)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>xshell连linux后ctrl&#43;s卡死</title>
      <link>http://cuick.github.io/linux/notes_stu/</link>
      <pubDate>Wed, 06 Apr 2016 18:30:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/linux/notes_stu/</guid>
      <description>&lt;p&gt;在vim下ctrl+s整个xshell终端就死了，遇到好几次这种情况，网上查了下原来ctrl+s在LINUX里是锁定屏幕的快捷键，解锁ctrl+q就可以了&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vim-markdown插件</title>
      <link>http://cuick.github.io/vim/101/</link>
      <pubDate>Wed, 06 Apr 2016 17:40:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/vim/101/</guid>
      <description>&lt;p&gt;插件目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  |-- syntax
  |   |-- mkd.vim
  |-- ftdetect
  |   |-- mkd.vim 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将两个 mkd.vim 分别复制到 $VIM 下对应的 syntax 和 ftdetect 文件夹中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp ./syntax/mkd.vim ~/.vim/syntax/
cp ./ftdetect/mkd.vim ~/.vim/ftdetect/ 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>redis执行lua脚本</title>
      <link>http://cuick.github.io/redis/101/</link>
      <pubDate>Wed, 06 Apr 2016 16:44:00 +0800</pubDate>
      
      <guid>http://cuick.github.io/redis/101/</guid>
      <description>

&lt;h2 id=&#34;好处:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;好处&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;减少网络开销：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原子操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;lua脚本demo:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;lua脚本demo&lt;/h2&gt;

&lt;p&gt;ratelimiting.lua&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local times = redis.call(&#39;incr&#39;,KEYS[1])

if times == 1 then
    redis.call(&#39;expire&#39;,KEYS[1], ARGV[1])
end

if times &amp;gt; tonumber(ARGV[2]) then
    return 0
end
return 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;执行脚本:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;执行脚本&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redis-cli --eval ratelimiting.lua rate.limitingl:127.0.0.1 , 10 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;eval参数是告诉redis-cli读取并运行后面的Lua脚本，ratelimiting.lua是脚本的位置，后面跟着是传给Lua脚本的参数。其中&amp;rdquo;,&amp;ldquo;前的rate.limiting:127.0.0.1是要操作的键，可以再脚本中用KEYS[1]获取，&amp;rdquo;,&amp;ldquo;后面的10和3是参数，在脚本中能够使用ARGV[1]和ARGV[2]获得。注：&amp;rdquo;,&amp;ldquo;两边的空格不能省略，否则会出错
结合脚本的内容可知这行命令的作用是将访问频率限制为每10秒最多3次，所以在终端中不断的运行此命令会发现当访问频率在10秒内小于或等于3次时返回1，否则返回0。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>