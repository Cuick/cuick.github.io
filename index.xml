<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K&#39;s blog!</title>
    <link>http://cuick.github.io/</link>
    <description>Recent content on K&#39;s blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 03 Mar 2016 17:26:29 +0800</lastBuildDate>
    <atom:link href="http://cuick.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hugo基本操作命令</title>
      <link>http://cuick.github.io/hugo/hugo_command/</link>
      <pubDate>Thu, 03 Mar 2016 17:26:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/hugo/hugo_command/</guid>
      <description>

&lt;h2 id=&#34;注意点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;注意点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建一个新的文档后，默认是draft属性是true&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;常用命令:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;常用命令&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;本地执行&lt;br /&gt;
hugo server &amp;ndash;theme=hugo-redlounge &amp;ndash;buildDrafts&lt;/li&gt;
&lt;li&gt;创建一个文档&lt;br /&gt;
hugo new hugo/101.md&lt;/li&gt;
&lt;li&gt;创建一个项目&lt;br /&gt;
hugo new site blols&lt;/li&gt;
&lt;li&gt;生成静态网站&lt;br /&gt;
hugo &amp;ndash;theme=hugo-redlounge &amp;ndash;baseUrl=&amp;ldquo;&lt;a href=&#34;http://cuick.github.io/&amp;quot;&#34;&gt;http://cuick.github.io/&amp;quot;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Markdown快速入门</title>
      <link>http://cuick.github.io/markdown/markdown_stu/</link>
      <pubDate>Thu, 03 Mar 2016 16:57:08 +0800</pubDate>
      
      <guid>http://cuick.github.io/markdown/markdown_stu/</guid>
      <description>

&lt;h1 id=&#34;教程地址:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;教程地址&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;http://wowubuntu.com/markdown/&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;因为本站就是用markdown编辑，所以，本文是从教程地址直接复制文章过来，然后以markdown的code方式显示出来， 直接在编辑文章处删除相关注释，就可查看例子效果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;段落、标题、区块代码

一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。

Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。

区块引用则使用 email 形式的 &#39;&amp;gt;&#39; 角括号。

Markdown 语法:

A First Level Header
====================
A Second Level Header
---------------------

Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.

The quick brown fox jumped over the lazy
dog&#39;s back.
Header 3

&amp;gt; This is a blockquote.
&amp;gt;
&amp;gt;&amp;gt; This is the second paragraph in the blockquote.
&amp;gt;
&amp;gt; ## This is an H2 in a blockquote

输出 HTML 为：

&amp;lt;h1&amp;gt;A First Level Header&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;A Second Level Header&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The quick brown fox jumped over the lazy
dog&#39;s back.&amp;lt;/p&amp;gt;
&amp;lt;h3&amp;gt;Header 3&amp;lt;/h3&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;This is a blockquote.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;This is the second paragraph in the blockquote.&amp;lt;/p&amp;gt;
&amp;lt;h2&amp;gt;This is an H2 in a blockquote&amp;lt;/h2&amp;gt;
&amp;lt;/blockquote&amp;gt;

修辞和强调

Markdown 使用星号和底线来标记需要强调的区段。

Markdown 语法:

Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.

输出 HTML 为:

&amp;lt;p&amp;gt;Some of these words &amp;lt;em&amp;gt;are emphasized&amp;lt;/em&amp;gt;.
Some of these words &amp;lt;em&amp;gt;are emphasized also&amp;lt;/em&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Use two asterisks for &amp;lt;strong&amp;gt;strong emphasis&amp;lt;/strong&amp;gt;.
Or, if you prefer, &amp;lt;strong&amp;gt;use two underscores instead&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;

列表

无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：

* Candy.
* Gum.
* Booze.

加号：

+ Candy.
+ Gum.
+ Booze.

和减号

- Candy.
- Gum.
- Booze.

都会输出 HTML 为：

&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Candy.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Gum.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Booze.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

有序的列表则是使用一般的数字接着一个英文句点作为项目标记：

1. Red
2. Green
3. Blue

输出 HTML 为：

&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Red&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Green&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Blue&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;

如果你在项目之间插入空行，那项目的内容会用 &amp;lt;p&amp;gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。

* A list item.

    With multiple paragraphs.

    * Another item in the list.

输出 HTML 为：

&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;A list item.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;With multiple paragraphs.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Another item in the list.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

链接

Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。

行内形式是直接在后面用括号直接接上链接：

This is an [example link](http://example.com/).

输出 HTML 为：

&amp;lt;p&amp;gt;This is an &amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

你也可以选择性的加上 title 属性：

This is an [example link](http://example.com/ &amp;quot;With a Title&amp;quot;).

输出 HTML 为：

&amp;lt;p&amp;gt;This is an &amp;lt;a href=&amp;quot;http://example.com/&amp;quot; title=&amp;quot;With a Title&amp;quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：

I get 10 times more traffic from [Google][1] than from
[Yahoo][2] or [MSN][3].

[1]: http://google.com/ &amp;quot;Google&amp;quot;
[2]: http://search.yahoo.com/ &amp;quot;Yahoo Search&amp;quot;
[3]: http://search.msn.com/ &amp;quot;MSN Search&amp;quot;

输出 HTML 为：

&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&amp;quot;http://google.com/&amp;quot;
title=&amp;quot;Google&amp;quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from &amp;lt;a href=&amp;quot;http://search.yahoo.com/&amp;quot;
title=&amp;quot;Yahoo Search&amp;quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt; or &amp;lt;a href=&amp;quot;http://search.msn.com/&amp;quot;
title=&amp;quot;MSN Search&amp;quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：

I start my morning with a cup of coffee and
[The New York Times][NY Times].

[ny times]: http://www.nytimes.com/

输出 HTML 为：

&amp;lt;p&amp;gt;I start my morning with a cup of coffee and
&amp;lt;a href=&amp;quot;http://www.nytimes.com/&amp;quot;&amp;gt;The New York Times&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

图片

图片的语法和链接很像。

行内形式（title 是选择性的）：

![alt text](/path/to/img.jpg &amp;quot;Title&amp;quot;)

参考形式：

![alt text][id]

[id]: /path/to/img.jpg &amp;quot;Title&amp;quot;

上面两种方法都会输出 HTML 为：

&amp;lt;img src=&amp;quot;/path/to/img.jpg&amp;quot; alt=&amp;quot;alt text&amp;quot; title=&amp;quot;Title&amp;quot; /&amp;gt;

代码

在一般的段落文字中，你可以使用反引号 \` 来标记代码区段，区段内的 &amp;amp;、&amp;lt; 和 &amp;gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：

I strongly recommend against using any `&amp;lt;blink&amp;gt;` tags.

I wish SmartyPants used named entities like `&amp;amp;mdash;`  
instead of decimal-encoded entites like `&amp;amp;#8212;`.

输出 HTML 为：

&amp;lt;p&amp;gt;I strongly recommend against using any
&amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;I wish SmartyPants used named entities like
&amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt; instead of decimal-encoded
entites like &amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;

如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;amp;、&amp;lt; 和 &amp;gt; 也一样会自动转成 HTML 实体。

Markdown 语法:

If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:

    &amp;lt;blockquote&amp;gt;
    &amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;
    &amp;lt;/blockquote&amp;gt;

输出 HTML 为：

&amp;lt;p&amp;gt;If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:&amp;lt;/p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;blockquote&amp;amp;gt;
&amp;amp;lt;p&amp;amp;gt;For example.&amp;amp;lt;/p&amp;amp;gt;
&amp;amp;lt;/blockquote&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Twisted学习笔记</title>
      <link>http://cuick.github.io/twisted/twisted_basic/</link>
      <pubDate>Sat, 27 Feb 2016 22:17:23 +0800</pubDate>
      
      <guid>http://cuick.github.io/twisted/twisted_basic/</guid>
      <description>

&lt;h1 id=&#34;网络编程:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;网络编程&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;poll&lt;/li&gt;
&lt;li&gt;epoll&lt;/li&gt;
&lt;li&gt;greenlet&lt;/li&gt;
&lt;li&gt;gevent&lt;/li&gt;
&lt;li&gt;gevent是基于协程的高性能Python网络库，相比Twisted、Stackless等，gevent使用libev事件循环，因此速度很快、性能很好，使用greenlet提供高层的同步API，因此非常轻量。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elias.cn/Python/PyConcurrency&#34;&gt;http://www.elias.cn/Python/PyConcurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/yueguanghaidao/&#34;&gt;http://blog.csdn.net/yueguanghaidao/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;twisted:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Twisted&lt;/h1&gt;

&lt;h3 id=&#34;twisted特点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;twisted特点：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在一个回调函数执行过程中，实际上Twisted的循环是被有效地阻塞在我们的代码上的。因此，因此我们应该确保回调函数不要浪费时间（尽快返回）。&lt;/li&gt;
&lt;li&gt;很多标准的Python方法没有办法转换为非阻塞方式。例如，os.system中的很多方法会在子进程完成前一直处于阻塞状态。这也就是它工作的方式。所以当你使用Twisted时，避开使用os.system。&lt;/li&gt;
&lt;li&gt;我们为Twisted程序写的API必须是异步的&lt;/li&gt;
&lt;li&gt;不能将同步与异步代码混合起来使用&lt;/li&gt;
&lt;li&gt;我们可以在自己的代码中写回调函数，正如Twisted做的那样&lt;/li&gt;
&lt;li&gt;并且，我们需要写处理错误信息的回调函数&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;reactor:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Reactor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个真正reactor模式的实现是需要实现循环独立抽象出来并具有如下的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;监视一系列与你I/O操作相关的文件描述符（description)&lt;/li&gt;
&lt;li&gt;不停地向你汇报那些准备好I/O操作的文件描述符&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个设计优秀的reactor模式实现需要做到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;处理所有不同系统会出现的I/O事件&lt;/li&gt;
&lt;li&gt;提供优雅的抽象来帮助你在使用reactor时少花些心思去考虑它的存在&lt;/li&gt;
&lt;li&gt;提供你可以在抽象层外（treactor实现）使用的公共协议实现。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reactor特性&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用twisted.internet.pollreactor中的系统调用来poll 来代替select方法&lt;br /&gt;
from twited.internet import pollreactor&lt;br /&gt;
pollreactor.install()&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
reactor.run()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;transports:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Transports&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个Twisted的Transport代表一个可以收发字节的单条连接。对于我们的诗歌下载客户端而言，就是对一条TCP连接的抽象。&lt;/li&gt;
&lt;li&gt;ransport抽象可以代表任何这样的连接并为其代表的连接处理具体的异步I/O操作细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocols:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocols&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个具体的Twisted的Protocol的实现应该对应一个具体网络协议的实现，像FTP、IMAP或其它我们自己规定的协议。&lt;/li&gt;
&lt;li&gt;每一个Twisted的Protocols类实例都为一个具体的连接提供协议解析。&lt;/li&gt;
&lt;li&gt;Protocol实例是存储协议状态与间断性接收并累积数据的地方（由于我们是通过异步I/O方式以任意大小来接收数据的）。&lt;/li&gt;
&lt;li&gt;Protocol实例如何得知它为哪条连接服务呢？如果你阅读IProtocol定义会发现一个makeConnection函数。这是一个回调函数，Twisted会在调用它时传递给其一个也是仅有的一个参数，即就是Transport实例。这个Transport实例就代表Protocol将要使用的连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocol-factories:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocol Factories&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个连接需要一个自己的Portocol&lt;/li&gt;
&lt;li&gt;Protocol Factories一个新的连接制定一个合适的协议&lt;/li&gt;
&lt;li&gt;Protocol Factory就是Factory模式的一个具体实现。&lt;/li&gt;
&lt;li&gt;buildProtocol方法在每次被调用时返回一个新Protocol实例。它就是Twisted用来为新连接创建新Protocol实例的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;failure:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Failure&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果有异常出现的话，其能捕获Exception与跟踪栈。&lt;/li&gt;
&lt;li&gt;将一个Failure对象付给回调函数，我们就可以为以后的调试保存跟踪栈的信息了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关于回调:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;关于回调&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;激活errback是非常重要的。由于errback的功能与except块相同，因此用户需要确保它们的存在。他们并不可选项，而是必选项。&lt;/li&gt;
&lt;li&gt;不在错误的时间点激活回调与在正确的时间点激活回调同等重要。典型的用法是，callback与errback是互斥的即只能运行其中一个。&lt;/li&gt;
&lt;li&gt;使用回调函数的代码重构起来有些困难。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deferred-以让程序员在使用回调时更简便:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred-以让程序员在使用回调时更简便&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;我们不能忽视errback，在任何异步编程的API中都需要它。Deferred支持errbacks。&lt;/li&gt;
&lt;li&gt;激活回调多次可能会导致很严重的问题。Deferred只能被激活一次，这就类似于同步编程中的try/except的处理方法。&lt;/li&gt;
&lt;li&gt;含有回调的程序在重构时相当困难。有了deferred，我们就通过修改回调链来重构程序。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>notes</title>
      <link>http://cuick.github.io/notes/notes_stu/</link>
      <pubDate>Fri, 26 Feb 2016 14:39:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/notes/notes_stu/</guid>
      <description>

&lt;h4 id=&#34;知识点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;知识点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Markdown&lt;/li&gt;
&lt;li&gt;llvm&lt;/li&gt;
&lt;li&gt;python:

&lt;ul&gt;
&lt;li&gt;optparse 处理命令行参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;图标字体
&lt;a href=&#34;http://fontawesome.dashgame.com/&#34;&gt;http://fontawesome.dashgame.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MENU</title>
      <link>http://cuick.github.io/menu/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:01 +0800</pubDate>
      
      <guid>http://cuick.github.io/menu/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;点击上面的标签，打开相关文章列表&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>