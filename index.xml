<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K&#39;s blog!</title>
    <link>http://cuick.github.io/</link>
    <description>Recent content on K&#39;s blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 19 Mar 2016 21:15:49 +0800</lastBuildDate>
    <atom:link href="http://cuick.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>线程安全与GIL</title>
      <link>http://cuick.github.io/python/102/</link>
      <pubDate>Sat, 19 Mar 2016 21:15:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/102/</guid>
      <description>

&lt;h2 id=&#34;引入:b66e25cf931c5c75968256c4152b6090&#34;&gt;引入&lt;/h2&gt;

&lt;p&gt;多核时代到来。为了更好利用多核，就要讲到进程与线程，区别在于是否共享资源，前者是独立的后这是共享的。&lt;br /&gt;
多线程环境最大的问题就是资源的竞争 死锁 数据修改。
于是就有了线程安全的问题。&lt;/p&gt;

&lt;h2 id=&#34;线程安全:b66e25cf931c5c75968256c4152b6090&#34;&gt;线程安全&lt;/h2&gt;

&lt;p&gt;在多线程的环境下, 线程安全能够保证多个线程同时执行时程序依旧运行正确, 而且要保证对于共享的数据,可以由多个线程存取,但是同一时刻只能有一个线程进行存取.&lt;/p&gt;

&lt;p&gt;加锁可以保证存取操作的唯一性, 从而保证同一时刻只有一个线程对共享数据存取.&lt;/p&gt;

&lt;p&gt;通常加锁也有2种不同的粒度的锁:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fine-grained(所谓的细粒度), 那么程序员需要自行地加,解锁来保证线程安全&lt;/li&gt;
&lt;li&gt;coarse-grained(所谓的粗粒度), 那么语言层面本身维护着一个全局的锁机制,用来保证线程安全&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前一种方式比较典型的是 java, Jython 等, 后一种方式比较典型的是 CPython (即Python).&lt;/p&gt;

&lt;p&gt;Python中的全局锁机制,便是 GIL (Global Interpreter Lock)&lt;/p&gt;

&lt;h2 id=&#34;什么是gil:b66e25cf931c5c75968256c4152b6090&#34;&gt;什么是GIL&lt;/h2&gt;

&lt;p&gt;全局解释器锁（GIL）是一种互斥锁，由程序语言解析线程持有，用于避免代码共享可能导致的线程安全问题。在支持GIL的语言中，每一个解释器进程中都会含有一个GIL。&lt;/p&gt;

&lt;p&gt;每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.&lt;/p&gt;

&lt;p&gt;那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行, 多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.&lt;/p&gt;

&lt;h4 id=&#34;gil应用:b66e25cf931c5c75968256c4152b6090&#34;&gt;GIL应用&lt;/h4&gt;

&lt;p&gt;一些支持 GIL 的语言的实现包括 CPython（Python 语言最被广泛使用的一种实现），Ruby MRI（Ruby 的推荐实现，GIL 在 Ruby 中被称为 Global VM Lock）&lt;/p&gt;

&lt;p&gt;基于 JVM 的上述语言的等价实现（Jython 和 JRuby）不使用 GIL。IronPython 和 IronRuby 被实现成微软的动态语言运行时，并在其中避免使用 GIL 。&lt;/p&gt;

&lt;h4 id=&#34;关于gil的争议:b66e25cf931c5c75968256c4152b6090&#34;&gt;关于GIL的争议&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;认为应该去除 GIL 的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不顺应计算机的发展潮流(多核时代已经到来, 而 GIL 会很影响多核的使用)&lt;/li&gt;
&lt;li&gt;大幅度提升多线程程序的速度&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;认为不应该去除 GIL 的(如果去掉,会):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;写python的扩展(module)时会遇到锁的问题,程序员需要繁琐地加解锁来保证线程安全&lt;/li&gt;
&lt;li&gt;会较大幅度地减低单线程程序的速度&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;gil设计的缺陷:b66e25cf931c5c75968256c4152b6090&#34;&gt;GIL设计的缺陷&lt;/h4&gt;

&lt;p&gt;基于pcode数量的调度方式&lt;br /&gt;
为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度&lt;br /&gt;
当其他在其他核心上的线程被唤醒时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。&lt;/p&gt;

&lt;p&gt;Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。&lt;/p&gt;

&lt;h4 id=&#34;解决办法:b66e25cf931c5c75968256c4152b6090&#34;&gt;解决办法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;用multiprocess替代Thread&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。&lt;/p&gt;

&lt;p&gt;当然multiprocess也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocess由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。具体难点在哪有兴趣的读者可以扩展阅读 这篇文章&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用其他解析器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前也提到了既然GIL只是CPython的产物，那么其他解析器是不是更好呢？没错，像JPython和IronPython这样的解析器由于实现语言的特性，他们不需要GIL的帮助。然而由于用了Java/C#用于解析器实现，他们也失去了利用社区众多C语言模块有用特性的机会。所以这些解析器也因此一直都比较小众。毕竟功能和性能大家在初期都会选择前者， Done is better than perfect 。
所以没救了么？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;另一个改进 Reworking the GIL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将切换颗粒度从基于opcode计数改成基于时间片计数&lt;/li&gt;
&lt;li&gt;避免最近一次释放GIL锁的线程再次被立即调度&lt;/li&gt;
&lt;li&gt;新增线程优先级功能（高优先级线程可以迫使其他线程释放所持有的GIL锁）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结:b66e25cf931c5c75968256c4152b6090&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;Python GIL其实是功能和性能之间权衡后的产物，它尤其存在的合理性，也有较难改变的客观因素。从本分的分析中，我们可以做以下一些简单的总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GIL在较长一段时间内将会继续存在，但是会不断对其进行改进&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;参考文章:b66e25cf931c5c75968256c4152b6090&#34;&gt;参考文章：&lt;/h5&gt;

&lt;p&gt;1.&lt;a href=&#34;http://www.tuicool.com/articles/7zIra2r&#34;&gt;http://www.tuicool.com/articles/7zIra2r&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;http://my.oschina.net/moooofly/blog/178531&#34;&gt;http://my.oschina.net/moooofly/blog/178531&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>http://cuick.github.io/python/101/</link>
      <pubDate>Sat, 19 Mar 2016 20:24:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/python/101/</guid>
      <description>&lt;p&gt;闭包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def make_addr(addend):
    def addr(augend):
        return augend + addend
    return addr

p = make_addr(23)
q = make_addr(42)

print p(10)
print q(10)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>16年3月面试</title>
      <link>http://cuick.github.io/notes/102/</link>
      <pubDate>Fri, 18 Mar 2016 18:10:03 +0800</pubDate>
      
      <guid>http://cuick.github.io/notes/102/</guid>
      <description></description>
    </item>
    
    <item>
      <title>footer</title>
      <link>http://cuick.github.io/footer/</link>
      <pubDate>Fri, 18 Mar 2016 17:57:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/footer/</guid>
      <description>

&lt;h2 id=&#34;powered-by-hugo-https-github-com-spf13-hugo-with-hugo-redlounge-https-github-com-tmaiaroto-hugo-redlounge:b88206c9a05a97b8527e1f5cd9a8bba4&#34;&gt;Powered by &lt;a href=&#34;https://github.com/spf13/hugo&#34;&gt;Hugo&lt;/a&gt; with &lt;a href=&#34;https://github.com/tmaiaroto/hugo-redlounge&#34;&gt;hugo-redlounge&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;有问题请微博私信:b88206c9a05a97b8527e1f5cd9a8bba4&#34;&gt;有问题请微博私信&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Django笔记(一)</title>
      <link>http://cuick.github.io/django/101/</link>
      <pubDate>Tue, 15 Mar 2016 22:06:53 +0800</pubDate>
      
      <guid>http://cuick.github.io/django/101/</guid>
      <description>

&lt;h2 id=&#34;安装:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;同其他python模块的安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pip install Django==1.9.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基本命令:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;基本命令&lt;/h2&gt;

&lt;h4 id=&#34;1-新建一个-django-projec:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;1.新建一个 django projec:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;django-admin.py startproject project-name

mysite
├── manage.py
└── mysite
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建了一个 mysite 目录，其中还有一个 mysite 目录&lt;br /&gt;
一些项目的设置 settings.py 文件，&lt;br /&gt;
总的urls配置文件 urls.py&lt;br /&gt;
部署服务器时用到的 wsgi.py 文件，&lt;br /&gt;
&lt;strong&gt;init&lt;/strong&gt;.py 是python包的目录结构必须的，与调用有关。&lt;/p&gt;

&lt;h4 id=&#34;2-新建-app:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;2.新建 app:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;python manage.py startapp app-name
django-admin.py startapp app-name
app-name/
├── __init__.py
├── admin.py
├── models.py
├── tests.py
└── views.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把我们新定义的app加到settings.py中的INSTALL_APPS中&lt;br /&gt;
修改 mysite/mysite/settings.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,

    &#39;myapp&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用开发服务器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Hugo 文章配置toml</title>
      <link>http://cuick.github.io/hugo/hugo_content_config/</link>
      <pubDate>Thu, 03 Mar 2016 17:26:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/hugo/hugo_content_config/</guid>
      <description>

&lt;h1 id=&#34;常用配置项:b66e25cf931c5c75968256c4152b6090&#34;&gt;常用配置项&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;date = &amp;ldquo;1970-01-01T00:00:01+08:00&amp;rdquo;&lt;/li&gt;
&lt;li&gt;title = &amp;ldquo;MENU&amp;rdquo;&lt;/li&gt;
&lt;li&gt;文章排序等级&lt;br /&gt;
weight = 999&lt;/li&gt;
&lt;li&gt;series = [ &amp;ldquo;hugo content config&amp;rdquo; ]&lt;/li&gt;
&lt;li&gt;分类&lt;br /&gt;
categories = [&amp;ldquo;VIM&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;标签
tags = [ &amp;ldquo;Markdown&amp;rdquo;, &amp;ldquo;编程语言&amp;rdquo;, &amp;ldquo;Hugo&amp;rdquo;, &amp;ldquo;command&amp;rdquo; , &amp;ldquo;标记语言&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;不显示写文章时间&lt;br /&gt;
nodate = true&lt;/li&gt;
&lt;li&gt;url里的name&lt;br /&gt;
slug = &amp;ldquo;menu&amp;rdquo;&lt;/li&gt;
&lt;li&gt;隐藏上下页&lt;br /&gt;
nopaging = true&lt;/li&gt;
&lt;li&gt;隐藏读取时间&lt;br /&gt;
noread = true&lt;/li&gt;
&lt;li&gt;显示作者&lt;br /&gt;
author = &amp;ldquo;崔程凯&amp;rdquo;&lt;/li&gt;
&lt;li&gt;隐藏作者&lt;br /&gt;
noauthor = true&lt;/li&gt;
&lt;li&gt;topics = [ &amp;ldquo;Development&amp;rdquo;, &amp;ldquo;Go&amp;rdquo; ]&lt;/li&gt;
&lt;li&gt;description = &amp;ldquo;description.&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Hugo基本操作命令</title>
      <link>http://cuick.github.io/hugo/hugo_command/</link>
      <pubDate>Thu, 03 Mar 2016 17:26:29 +0800</pubDate>
      
      <guid>http://cuick.github.io/hugo/hugo_command/</guid>
      <description>

&lt;h2 id=&#34;注意点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;注意点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建一个新的文档后，默认是draft属性是true&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;常用命令:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;常用命令&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;本地执行&lt;br /&gt;
hugo server &amp;ndash;theme=hugo-redlounge &amp;ndash;buildDrafts&lt;/li&gt;
&lt;li&gt;创建一个文档&lt;br /&gt;
hugo new hugo/101.md&lt;/li&gt;
&lt;li&gt;创建一个项目&lt;br /&gt;
hugo new site blols&lt;/li&gt;
&lt;li&gt;生成静态网站&lt;br /&gt;
hugo &amp;ndash;theme=hugo-redlounge &amp;ndash;baseUrl=&amp;ldquo;&lt;a href=&#34;http://cuick.github.io/&amp;quot;&#34;&gt;http://cuick.github.io/&amp;quot;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Markdown快速入门</title>
      <link>http://cuick.github.io/markdown/markdown_stu/</link>
      <pubDate>Thu, 03 Mar 2016 16:57:08 +0800</pubDate>
      
      <guid>http://cuick.github.io/markdown/markdown_stu/</guid>
      <description>

&lt;h1 id=&#34;教程地址:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;教程地址&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;http://wowubuntu.com/markdown/&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;因为本站就是用markdown编辑，所以，本文是从教程地址直接复制文章过来，然后以markdown的code方式显示出来， 直接在编辑文章处删除相关注释，就可查看例子效果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;段落、标题、区块代码

一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。

Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。

区块引用则使用 email 形式的 &#39;&amp;gt;&#39; 角括号。

Markdown 语法:

A First Level Header
====================
A Second Level Header
---------------------


Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.

The quick brown fox jumped over the lazy
dog&#39;s back.
Header 3

&amp;gt; This is a blockquote.
&amp;gt;
&amp;gt;&amp;gt; This is the second paragraph in the blockquote.
&amp;gt;
&amp;gt; ## This is an H2 in a blockquote

输出 HTML 为：

&amp;lt;h1&amp;gt;A First Level Header&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;A Second Level Header&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The quick brown fox jumped over the lazy
dog&#39;s back.&amp;lt;/p&amp;gt;
&amp;lt;h3&amp;gt;Header 3&amp;lt;/h3&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;This is a blockquote.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;This is the second paragraph in the blockquote.&amp;lt;/p&amp;gt;
&amp;lt;h2&amp;gt;This is an H2 in a blockquote&amp;lt;/h2&amp;gt;
&amp;lt;/blockquote&amp;gt;

修辞和强调

Markdown 使用星号和底线来标记需要强调的区段。

Markdown 语法:

Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.

输出 HTML 为:

&amp;lt;p&amp;gt;Some of these words &amp;lt;em&amp;gt;are emphasized&amp;lt;/em&amp;gt;.
Some of these words &amp;lt;em&amp;gt;are emphasized also&amp;lt;/em&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Use two asterisks for &amp;lt;strong&amp;gt;strong emphasis&amp;lt;/strong&amp;gt;.
Or, if you prefer, &amp;lt;strong&amp;gt;use two underscores instead&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;

列表

无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：

* Candy.
* Gum.
* Booze.

加号：

+ Candy.
+ Gum.
+ Booze.

和减号

- Candy.
- Gum.
- Booze.

都会输出 HTML 为：

&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Candy.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Gum.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Booze.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

有序的列表则是使用一般的数字接着一个英文句点作为项目标记：

1. Red
2. Green
3. Blue

输出 HTML 为：

&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Red&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Green&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Blue&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;

如果你在项目之间插入空行，那项目的内容会用 &amp;lt;p&amp;gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。

* A list item.

    With multiple paragraphs.

    * Another item in the list.

输出 HTML 为：

&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;A list item.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;With multiple paragraphs.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Another item in the list.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

链接

Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。

行内形式是直接在后面用括号直接接上链接：

This is an [example link](http://example.com/).

输出 HTML 为：

&amp;lt;p&amp;gt;This is an &amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

你也可以选择性的加上 title 属性：

This is an [example link](http://example.com/ &amp;quot;With a Title&amp;quot;).

输出 HTML 为：

&amp;lt;p&amp;gt;This is an &amp;lt;a href=&amp;quot;http://example.com/&amp;quot; title=&amp;quot;With a Title&amp;quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：

I get 10 times more traffic from [Google][1] than from
[Yahoo][2] or [MSN][3].

[1]: http://google.com/ &amp;quot;Google&amp;quot;
[2]: http://search.yahoo.com/ &amp;quot;Yahoo Search&amp;quot;
[3]: http://search.msn.com/ &amp;quot;MSN Search&amp;quot;

输出 HTML 为：

&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&amp;quot;http://google.com/&amp;quot;
title=&amp;quot;Google&amp;quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from &amp;lt;a href=&amp;quot;http://search.yahoo.com/&amp;quot;
title=&amp;quot;Yahoo Search&amp;quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt; or &amp;lt;a href=&amp;quot;http://search.msn.com/&amp;quot;
title=&amp;quot;MSN Search&amp;quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：

I start my morning with a cup of coffee and
[The New York Times][NY Times].

[ny times]: http://www.nytimes.com/

输出 HTML 为：

&amp;lt;p&amp;gt;I start my morning with a cup of coffee and
&amp;lt;a href=&amp;quot;http://www.nytimes.com/&amp;quot;&amp;gt;The New York Times&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

图片

图片的语法和链接很像。

行内形式（title 是选择性的）：

![alt text](/path/to/img.jpg &amp;quot;Title&amp;quot;)

参考形式：

![alt text][id]

[id]: /path/to/img.jpg &amp;quot;Title&amp;quot;

上面两种方法都会输出 HTML 为：

&amp;lt;img src=&amp;quot;/path/to/img.jpg&amp;quot; alt=&amp;quot;alt text&amp;quot; title=&amp;quot;Title&amp;quot; /&amp;gt;

代码

在一般的段落文字中，你可以使用反引号 \` 来标记代码区段，区段内的 &amp;amp;、&amp;lt; 和 &amp;gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：

I strongly recommend against using any `&amp;lt;blink&amp;gt;` tags.

I wish SmartyPants used named entities like `&amp;amp;mdash;`  
instead of decimal-encoded entites like `&amp;amp;#8212;`.

输出 HTML 为：

&amp;lt;p&amp;gt;I strongly recommend against using any
&amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;I wish SmartyPants used named entities like
&amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt; instead of decimal-encoded
entites like &amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;

如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;amp;、&amp;lt; 和 &amp;gt; 也一样会自动转成 HTML 实体。

Markdown 语法:

If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:

    &amp;lt;blockquote&amp;gt;
    &amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;
    &amp;lt;/blockquote&amp;gt;

输出 HTML 为：

&amp;lt;p&amp;gt;If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:&amp;lt;/p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;blockquote&amp;amp;gt;
&amp;amp;lt;p&amp;amp;gt;For example.&amp;amp;lt;/p&amp;amp;gt;
&amp;amp;lt;/blockquote&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Twisted基础</title>
      <link>http://cuick.github.io/twisted/twisted_basic/</link>
      <pubDate>Sat, 27 Feb 2016 22:17:23 +0800</pubDate>
      
      <guid>http://cuick.github.io/twisted/twisted_basic/</guid>
      <description>

&lt;h1 id=&#34;网络编程:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;网络编程&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;poll&lt;/li&gt;
&lt;li&gt;epoll&lt;/li&gt;
&lt;li&gt;greenlet&lt;/li&gt;
&lt;li&gt;gevent&lt;/li&gt;
&lt;li&gt;gevent是基于协程的高性能Python网络库，相比Twisted、Stackless等，gevent使用libev事件循环，因此速度很快、性能很好，使用greenlet提供高层的同步API，因此非常轻量。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.elias.cn/Python/PyConcurrency&#34;&gt;http://www.elias.cn/Python/PyConcurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/yueguanghaidao/&#34;&gt;http://blog.csdn.net/yueguanghaidao/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;twisted:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Twisted&lt;/h1&gt;

&lt;h3 id=&#34;twisted特点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;twisted特点：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在一个回调函数执行过程中，实际上Twisted的循环是被有效地阻塞在我们的代码上的。因此，因此我们应该确保回调函数不要浪费时间（尽快返回）。&lt;/li&gt;
&lt;li&gt;很多标准的Python方法没有办法转换为非阻塞方式。例如，os.system中的很多方法会在子进程完成前一直处于阻塞状态。这也就是它工作的方式。所以当你使用Twisted时，避开使用os.system。&lt;/li&gt;
&lt;li&gt;我们为Twisted程序写的API必须是异步的&lt;/li&gt;
&lt;li&gt;不能将同步与异步代码混合起来使用&lt;/li&gt;
&lt;li&gt;我们可以在自己的代码中写回调函数，正如Twisted做的那样&lt;/li&gt;
&lt;li&gt;并且，我们需要写处理错误信息的回调函数&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;reactor:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Reactor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个真正reactor模式的实现是需要实现循环独立抽象出来并具有如下的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;监视一系列与你I/O操作相关的文件描述符（description)&lt;/li&gt;
&lt;li&gt;不停地向你汇报那些准备好I/O操作的文件描述符&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个设计优秀的reactor模式实现需要做到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;处理所有不同系统会出现的I/O事件&lt;/li&gt;
&lt;li&gt;提供优雅的抽象来帮助你在使用reactor时少花些心思去考虑它的存在&lt;/li&gt;
&lt;li&gt;提供你可以在抽象层外（treactor实现）使用的公共协议实现。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reactor特性&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用twisted.internet.pollreactor中的系统调用来poll 来代替select方法&lt;br /&gt;
from twited.internet import pollreactor&lt;br /&gt;
pollreactor.install()&lt;br /&gt;
from twisted.internet import reactor&lt;br /&gt;
reactor.run()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;transports:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Transports&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个Twisted的Transport代表一个可以收发字节的单条连接。对于我们的诗歌下载客户端而言，就是对一条TCP连接的抽象。&lt;/li&gt;
&lt;li&gt;ransport抽象可以代表任何这样的连接并为其代表的连接处理具体的异步I/O操作细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocols:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocols&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个具体的Twisted的Protocol的实现应该对应一个具体网络协议的实现，像FTP、IMAP或其它我们自己规定的协议。&lt;/li&gt;
&lt;li&gt;每一个Twisted的Protocols类实例都为一个具体的连接提供协议解析。&lt;/li&gt;
&lt;li&gt;Protocol实例是存储协议状态与间断性接收并累积数据的地方（由于我们是通过异步I/O方式以任意大小来接收数据的）。&lt;/li&gt;
&lt;li&gt;Protocol实例如何得知它为哪条连接服务呢？如果你阅读IProtocol定义会发现一个makeConnection函数。这是一个回调函数，Twisted会在调用它时传递给其一个也是仅有的一个参数，即就是Transport实例。这个Transport实例就代表Protocol将要使用的连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;protocol-factories:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Protocol Factories&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个连接需要一个自己的Portocol&lt;/li&gt;
&lt;li&gt;Protocol Factories一个新的连接制定一个合适的协议&lt;/li&gt;
&lt;li&gt;Protocol Factory就是Factory模式的一个具体实现。&lt;/li&gt;
&lt;li&gt;buildProtocol方法在每次被调用时返回一个新Protocol实例。它就是Twisted用来为新连接创建新Protocol实例的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;failure:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Failure&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果有异常出现的话，其能捕获Exception与跟踪栈。&lt;/li&gt;
&lt;li&gt;将一个Failure对象付给回调函数，我们就可以为以后的调试保存跟踪栈的信息了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关于回调:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;关于回调&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;激活errback是非常重要的。由于errback的功能与except块相同，因此用户需要确保它们的存在。他们并不可选项，而是必选项。&lt;/li&gt;
&lt;li&gt;不在错误的时间点激活回调与在正确的时间点激活回调同等重要。典型的用法是，callback与errback是互斥的即只能运行其中一个。&lt;/li&gt;
&lt;li&gt;使用回调函数的代码重构起来有些困难。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deferred-以让程序员在使用回调时更简便:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred-以让程序员在使用回调时更简便&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;

&lt;ol&gt;
&lt;li&gt;我们不能忽视errback，在任何异步编程的API中都需要它。Deferred支持errbacks。&lt;/li&gt;
&lt;li&gt;激活回调多次可能会导致很严重的问题。Deferred只能被激活一次，这就类似于同步编程中的try/except的处理方法。&lt;/li&gt;
&lt;li&gt;含有回调的程序在重构时相当困难。有了deferred，我们就通过修改回调链来重构程序。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;一个deferred有一个callback/errback对链，它们以添加到deferred中的顺序依次排列&lt;/li&gt;
&lt;li&gt;stage 0，即第一对errback/callbac，会在deferred激活时调用，具体调用那个看激活deferred的方式，若是通过.errback激活，则调用errback；同样若是通过.callback激活则调用callback。（这里的errback/callback实际是指通过addBoth添加的函数）&lt;/li&gt;
&lt;li&gt;如果stage N执行出现异常，则stage N+1的errback被调用，并且其参数即为stage N出现的异常&lt;/li&gt;
&lt;li&gt;同样，如果stage N成功，即没有抛出异常，则N+1的callback被调用，其第一个参数为stage N的返回值。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务器用ServerFactory而不是ClientFactory, 这是因为服务器是要被动地监听连接状态而不是像客户端一样去主动的创建。使用listenTCP方法.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deferred进阶:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;Deferred进阶&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个deferred的回调链中的一个回函数可以再返回了一个 deferred&lt;/li&gt;
&lt;li&gt;当内层deferrd被激活时，外层的deferred恢复其回调链的执行。当内层deferred回调执行成功，那么外层deferred会调用第N+1个callback回调。相反，如果内层deferred执行失败，那么外层deferred会调用第N+1个errback回调
&lt;img src=&#34;http://cuick.github.io/twisted/deferred-111.png&#34; alt=&#34;deferred&#34; title=&#34;xxx&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>notes</title>
      <link>http://cuick.github.io/notes/notes_stu/</link>
      <pubDate>Fri, 26 Feb 2016 14:39:49 +0800</pubDate>
      
      <guid>http://cuick.github.io/notes/notes_stu/</guid>
      <description>

&lt;h4 id=&#34;知识点:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;知识点&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;好机记性如烂笔头，随手记下学习的知识点,有必要的将来整理成博客。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Markdown&lt;/li&gt;
&lt;li&gt;llvm&lt;/li&gt;
&lt;li&gt;python:

&lt;ul&gt;
&lt;li&gt;optparse 处理命令行参数&lt;/li&gt;
&lt;li&gt;Eve框架&lt;/li&gt;
&lt;li&gt;getattr(),setattr(),delattr(),hasattr()&lt;/li&gt;
&lt;li&gt;zope plone&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ajalt/fuckitpy&#34;&gt;https://github.com/ajalt/fuckitpy&lt;/a&gt; fuckitpy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;图标字体
&lt;a href=&#34;http://fontawesome.dashgame.com/&#34;&gt;http://fontawesome.dashgame.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;restful&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;计划:e4b8a5905536b2b2540aab2195e920f5&#34;&gt;计划&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;看完twisted&lt;/li&gt;
&lt;li&gt;系统的学一下python基础&lt;/li&gt;
&lt;li&gt;python库好好整理一下&lt;/li&gt;
&lt;li&gt;学习django&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;li&gt;js&lt;/li&gt;
&lt;li&gt;go erlang &amp;hellip;&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>